.TH "lsl::stream_outlet" 3 "Fri May 10 2019" "lslsub_dbfeeder" \" -*- nroff -*-
.ad l
.nh
.SH NAME
lsl::stream_outlet
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <lsl_cpp\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBstream_outlet\fP (const \fBstream_info\fP &\fBinfo\fP, int32_t chunk_size=0, int32_t max_buffered=360)"
.br
.ti -1c
.RI "template<class T , int32_t N> void \fBpush_sample\fP (const T data[N], double timestamp=0\&.0, bool pushthrough=true)"
.br
.ti -1c
.RI "void \fBpush_sample\fP (const std::vector< float > &data, double timestamp=0\&.0, bool pushthrough=true)"
.br
.ti -1c
.RI "void \fBpush_sample\fP (const std::vector< double > &data, double timestamp=0\&.0, bool pushthrough=true)"
.br
.ti -1c
.RI "void \fBpush_sample\fP (const std::vector< long > &data, double timestamp=0\&.0, bool pushthrough=true)"
.br
.ti -1c
.RI "void \fBpush_sample\fP (const std::vector< int32_t > &data, double timestamp=0\&.0, bool pushthrough=true)"
.br
.ti -1c
.RI "void \fBpush_sample\fP (const std::vector< int16_t > &data, double timestamp=0\&.0, bool pushthrough=true)"
.br
.ti -1c
.RI "void \fBpush_sample\fP (const std::vector< char > &data, double timestamp=0\&.0, bool pushthrough=true)"
.br
.ti -1c
.RI "void \fBpush_sample\fP (const std::vector< std::string > &data, double timestamp=0\&.0, bool pushthrough=true)"
.br
.ti -1c
.RI "void \fBpush_sample\fP (const float *data, double timestamp=0\&.0, bool pushthrough=true)"
.br
.ti -1c
.RI "void \fBpush_sample\fP (const double *data, double timestamp=0\&.0, bool pushthrough=true)"
.br
.ti -1c
.RI "void \fBpush_sample\fP (const long *data, double timestamp=0\&.0, bool pushthrough=true)"
.br
.ti -1c
.RI "void \fBpush_sample\fP (const int32_t *data, double timestamp=0\&.0, bool pushthrough=true)"
.br
.ti -1c
.RI "void \fBpush_sample\fP (const int16_t *data, double timestamp=0\&.0, bool pushthrough=true)"
.br
.ti -1c
.RI "void \fBpush_sample\fP (const char *data, double timestamp=0\&.0, bool pushthrough=true)"
.br
.ti -1c
.RI "void \fBpush_sample\fP (const std::string *data, double timestamp=0\&.0, bool pushthrough=true)"
.br
.ti -1c
.RI "template<class T > void \fBpush_numeric_struct\fP (const T &sample, double timestamp=0\&.0, bool pushthrough=true)"
.br
.ti -1c
.RI "void \fBpush_numeric_raw\fP (const void *sample, double timestamp=0\&.0, bool pushthrough=true)"
.br
.ti -1c
.RI "template<class T > void \fBpush_chunk\fP (const std::vector< T > &samples, double timestamp=0\&.0, bool pushthrough=true)"
.br
.ti -1c
.RI "template<class T > void \fBpush_chunk\fP (const std::vector< T > &samples, const std::vector< double > &timestamps, bool pushthrough=true)"
.br
.ti -1c
.RI "template<class T > void \fBpush_chunk_numeric_structs\fP (const std::vector< T > &samples, double timestamp=0\&.0, bool pushthrough=true)"
.br
.ti -1c
.RI "template<class T > void \fBpush_chunk_numeric_structs\fP (const std::vector< T > &samples, const std::vector< double > &timestamps, bool pushthrough=true)"
.br
.ti -1c
.RI "void \fBpush_chunk_multiplexed\fP (const std::vector< float > &buffer, double timestamp=0\&.0, bool pushthrough=true)"
.br
.ti -1c
.RI "void \fBpush_chunk_multiplexed\fP (const std::vector< double > &buffer, double timestamp=0\&.0, bool pushthrough=true)"
.br
.ti -1c
.RI "void \fBpush_chunk_multiplexed\fP (const std::vector< long > &buffer, double timestamp=0\&.0, bool pushthrough=true)"
.br
.ti -1c
.RI "void \fBpush_chunk_multiplexed\fP (const std::vector< int32_t > &buffer, double timestamp=0\&.0, bool pushthrough=true)"
.br
.ti -1c
.RI "void \fBpush_chunk_multiplexed\fP (const std::vector< int16_t > &buffer, double timestamp=0\&.0, bool pushthrough=true)"
.br
.ti -1c
.RI "void \fBpush_chunk_multiplexed\fP (const std::vector< char > &buffer, double timestamp=0\&.0, bool pushthrough=true)"
.br
.ti -1c
.RI "void \fBpush_chunk_multiplexed\fP (const std::vector< std::string > &buffer, double timestamp=0\&.0, bool pushthrough=true)"
.br
.ti -1c
.RI "void \fBpush_chunk_multiplexed\fP (const std::vector< float > &buffer, const std::vector< double > &timestamps, bool pushthrough=true)"
.br
.ti -1c
.RI "void \fBpush_chunk_multiplexed\fP (const std::vector< double > &buffer, const std::vector< double > &timestamps, bool pushthrough=true)"
.br
.ti -1c
.RI "void \fBpush_chunk_multiplexed\fP (const std::vector< long > &buffer, const std::vector< double > &timestamps, bool pushthrough=true)"
.br
.ti -1c
.RI "void \fBpush_chunk_multiplexed\fP (const std::vector< int32_t > &buffer, const std::vector< double > &timestamps, bool pushthrough=true)"
.br
.ti -1c
.RI "void \fBpush_chunk_multiplexed\fP (const std::vector< int16_t > &buffer, const std::vector< double > &timestamps, bool pushthrough=true)"
.br
.ti -1c
.RI "void \fBpush_chunk_multiplexed\fP (const std::vector< char > &buffer, const std::vector< double > &timestamps, bool pushthrough=true)"
.br
.ti -1c
.RI "void \fBpush_chunk_multiplexed\fP (const std::vector< std::string > &buffer, const std::vector< double > &timestamps, bool pushthrough=true)"
.br
.ti -1c
.RI "void \fBpush_chunk_multiplexed\fP (const float *buffer, std::size_t buffer_elements, double timestamp=0\&.0, bool pushthrough=true)"
.br
.ti -1c
.RI "void \fBpush_chunk_multiplexed\fP (const double *buffer, std::size_t buffer_elements, double timestamp=0\&.0, bool pushthrough=true)"
.br
.ti -1c
.RI "void \fBpush_chunk_multiplexed\fP (const long *buffer, std::size_t buffer_elements, double timestamp=0\&.0, bool pushthrough=true)"
.br
.ti -1c
.RI "void \fBpush_chunk_multiplexed\fP (const int32_t *buffer, std::size_t buffer_elements, double timestamp=0\&.0, bool pushthrough=true)"
.br
.ti -1c
.RI "void \fBpush_chunk_multiplexed\fP (const int16_t *buffer, std::size_t buffer_elements, double timestamp=0\&.0, bool pushthrough=true)"
.br
.ti -1c
.RI "void \fBpush_chunk_multiplexed\fP (const char *buffer, std::size_t buffer_elements, double timestamp=0\&.0, bool pushthrough=true)"
.br
.ti -1c
.RI "void \fBpush_chunk_multiplexed\fP (const std::string *buffer, std::size_t buffer_elements, double timestamp=0\&.0, bool pushthrough=true)"
.br
.ti -1c
.RI "void \fBpush_chunk_multiplexed\fP (const float *data_buffer, const double *timestamp_buffer, std::size_t data_buffer_elements, bool pushthrough=true)"
.br
.ti -1c
.RI "void \fBpush_chunk_multiplexed\fP (const double *data_buffer, const double *timestamp_buffer, std::size_t data_buffer_elements, bool pushthrough=true)"
.br
.ti -1c
.RI "void \fBpush_chunk_multiplexed\fP (const long *data_buffer, const double *timestamp_buffer, std::size_t data_buffer_elements, bool pushthrough=true)"
.br
.ti -1c
.RI "void \fBpush_chunk_multiplexed\fP (const int32_t *data_buffer, const double *timestamp_buffer, std::size_t data_buffer_elements, bool pushthrough=true)"
.br
.ti -1c
.RI "void \fBpush_chunk_multiplexed\fP (const int16_t *data_buffer, const double *timestamp_buffer, std::size_t data_buffer_elements, bool pushthrough=true)"
.br
.ti -1c
.RI "void \fBpush_chunk_multiplexed\fP (const char *data_buffer, const double *timestamp_buffer, std::size_t data_buffer_elements, bool pushthrough=true)"
.br
.ti -1c
.RI "void \fBpush_chunk_multiplexed\fP (const std::string *data_buffer, const double *timestamp_buffer, std::size_t data_buffer_elements, bool pushthrough=true)"
.br
.ti -1c
.RI "bool \fBhave_consumers\fP ()"
.br
.ti -1c
.RI "bool \fBwait_for_consumers\fP (double timeout)"
.br
.ti -1c
.RI "\fBstream_info\fP \fBinfo\fP () const"
.br
.ti -1c
.RI "\fB~stream_outlet\fP ()"
.br
.in -1c
.SH "Detailed Description"
.PP 
A stream outlet\&. Outlets are used to make streaming data (and the meta-data) available on the lab network\&. 
.SH "Constructor & Destructor Documentation"
.PP 
.SS "lsl::stream_outlet::stream_outlet (const \fBstream_info\fP & info, int32_t chunk_size = \fC0\fP, int32_t max_buffered = \fC360\fP)\fC [inline]\fP"
Establish a new stream outlet\&. This makes the stream discoverable\&. 
.PP
\fBParameters:\fP
.RS 4
\fIinfo\fP The stream information to use for creating this stream\&. Stays constant over the lifetime of the outlet\&. 
.br
\fIchunk_size\fP Optionally the desired chunk granularity (in samples) for transmission\&. If unspecified, each push operation yields one chunk\&. Inlets can override this setting\&. 
.br
\fImax_buffered\fP Optionally the maximum amount of data to buffer (in seconds if there is a nominal sampling rate, otherwise x100 in samples)\&. The default is 6 minutes of data\&. 
.RE
.PP

.SS "lsl::stream_outlet::~stream_outlet ()\fC [inline]\fP"
Destructor\&. The stream will no longer be discoverable after destruction and all paired inlets will stop delivering data\&. 
.SH "Member Function Documentation"
.PP 
.SS "bool lsl::stream_outlet::have_consumers ()\fC [inline]\fP"
Check whether consumers are currently registered\&. While it does not hurt, there is technically no reason to push samples if there is no consumer\&. 
.SS "\fBstream_info\fP lsl::stream_outlet::info () const\fC [inline]\fP"
Retrieve the stream info provided by this outlet\&. This is what was used to create the stream (and also has the Additional Network Information fields assigned)\&. 
.SS "template<class T > void lsl::stream_outlet::push_chunk (const std::vector< T > & samples, double timestamp = \fC0\&.0\fP, bool pushthrough = \fCtrue\fP)\fC [inline]\fP"
Push a chunk of samples (batched into an STL vector) into the outlet\&. 
.PP
\fBParameters:\fP
.RS 4
\fIsamples\fP A vector of samples in some supported format (each sample can be a data pointer, data array, or std vector of data)\&. 
.br
\fItimestamp\fP Optionally the capture time of the most recent sample, in agreement with \fBlocal_clock()\fP; if omitted, the current time is used\&. The time stamps of other samples are automatically derived according to the sampling rate of the stream\&. 
.br
\fIpushthrough\fP Whether to push the chunk through to the receivers instead of buffering it with subsequent samples\&. Note that the chunk_size, if specified at outlet construction, takes precedence over the pushthrough flag\&. 
.RE
.PP

.SS "template<class T > void lsl::stream_outlet::push_chunk (const std::vector< T > & samples, const std::vector< double > & timestamps, bool pushthrough = \fCtrue\fP)\fC [inline]\fP"
Push a chunk of samples (batched into an STL vector) into the outlet\&. Allows to specify a separate time stamp for each sample (for irregular-rate streams)\&. 
.PP
\fBParameters:\fP
.RS 4
\fIsamples\fP A vector of samples in some supported format (each sample can be a data pointer, data array, or std vector of data)\&. 
.br
\fItimestamps\fP A vector of capture times for each sample, in agreement with \fBlocal_clock()\fP\&. 
.br
\fIpushthrough\fP Whether to push the chunk through to the receivers instead of buffering it with subsequent samples\&. Note that the chunk_size, if specified at outlet construction, takes precedence over the pushthrough flag\&. 
.RE
.PP

.SS "void lsl::stream_outlet::push_chunk_multiplexed (const std::vector< float > & buffer, double timestamp = \fC0\&.0\fP, bool pushthrough = \fCtrue\fP)\fC [inline]\fP"
Push a chunk of multiplexed data into the outlet\&. 
.PP
\fBParameters:\fP
.RS 4
\fIbuffer\fP A buffer of channel values holding the data for zero or more successive samples to send\&. 
.br
\fItimestamp\fP Optionally the capture time of the most recent sample, in agreement with \fBlocal_clock()\fP; if omitted, the current time is used\&. The time stamps of other samples are automatically derived according to the sampling rate of the stream\&. 
.br
\fIpushthrough\fP Whether to push the chunk through to the receivers instead of buffering it with subsequent samples\&. Note that the chunk_size, if specified at outlet construction, takes precedence over the pushthrough flag\&. 
.RE
.PP

.SS "void lsl::stream_outlet::push_chunk_multiplexed (const std::vector< double > & buffer, double timestamp = \fC0\&.0\fP, bool pushthrough = \fCtrue\fP)\fC [inline]\fP"

.SS "void lsl::stream_outlet::push_chunk_multiplexed (const std::vector< long > & buffer, double timestamp = \fC0\&.0\fP, bool pushthrough = \fCtrue\fP)\fC [inline]\fP"

.SS "void lsl::stream_outlet::push_chunk_multiplexed (const std::vector< int32_t > & buffer, double timestamp = \fC0\&.0\fP, bool pushthrough = \fCtrue\fP)\fC [inline]\fP"

.SS "void lsl::stream_outlet::push_chunk_multiplexed (const std::vector< int16_t > & buffer, double timestamp = \fC0\&.0\fP, bool pushthrough = \fCtrue\fP)\fC [inline]\fP"

.SS "void lsl::stream_outlet::push_chunk_multiplexed (const std::vector< char > & buffer, double timestamp = \fC0\&.0\fP, bool pushthrough = \fCtrue\fP)\fC [inline]\fP"

.SS "void lsl::stream_outlet::push_chunk_multiplexed (const std::vector< std::string > & buffer, double timestamp = \fC0\&.0\fP, bool pushthrough = \fCtrue\fP)\fC [inline]\fP"

.SS "void lsl::stream_outlet::push_chunk_multiplexed (const std::vector< float > & buffer, const std::vector< double > & timestamps, bool pushthrough = \fCtrue\fP)\fC [inline]\fP"
Push a chunk of multiplexed data into the outlet\&. One timestamp per sample is provided\&. Allows to specify a separate time stamp for each sample (for irregular-rate streams)\&. 
.PP
\fBParameters:\fP
.RS 4
\fIdata_buffer\fP A buffer of channel values holding the data for zero or more successive samples to send\&. 
.br
\fItimestamps\fP A buffer of timestamp values holding time stamps for each sample in the data buffer\&. 
.br
\fIpushthrough\fP Whether to push the chunk through to the receivers instead of buffering it with subsequent samples\&. Note that the chunk_size, if specified at outlet construction, takes precedence over the pushthrough flag\&. 
.RE
.PP

.SS "void lsl::stream_outlet::push_chunk_multiplexed (const std::vector< double > & buffer, const std::vector< double > & timestamps, bool pushthrough = \fCtrue\fP)\fC [inline]\fP"

.SS "void lsl::stream_outlet::push_chunk_multiplexed (const std::vector< long > & buffer, const std::vector< double > & timestamps, bool pushthrough = \fCtrue\fP)\fC [inline]\fP"

.SS "void lsl::stream_outlet::push_chunk_multiplexed (const std::vector< int32_t > & buffer, const std::vector< double > & timestamps, bool pushthrough = \fCtrue\fP)\fC [inline]\fP"

.SS "void lsl::stream_outlet::push_chunk_multiplexed (const std::vector< int16_t > & buffer, const std::vector< double > & timestamps, bool pushthrough = \fCtrue\fP)\fC [inline]\fP"

.SS "void lsl::stream_outlet::push_chunk_multiplexed (const std::vector< char > & buffer, const std::vector< double > & timestamps, bool pushthrough = \fCtrue\fP)\fC [inline]\fP"

.SS "void lsl::stream_outlet::push_chunk_multiplexed (const std::vector< std::string > & buffer, const std::vector< double > & timestamps, bool pushthrough = \fCtrue\fP)\fC [inline]\fP"

.SS "void lsl::stream_outlet::push_chunk_multiplexed (const float * buffer, std::size_t buffer_elements, double timestamp = \fC0\&.0\fP, bool pushthrough = \fCtrue\fP)\fC [inline]\fP"
Push a chunk of multiplexed samples into the outlet\&. Single timestamp provided\&. IMPORTANT: Note that the provided buffer size is measured in channel values (e\&.g\&., floats) rather than in samples\&. 
.PP
\fBParameters:\fP
.RS 4
\fIbuffer\fP A buffer of channel values holding the data for zero or more successive samples to send\&. 
.br
\fIbuffer_elements\fP The number of channel values (of type T) in the buffer\&. Must be a multiple of the channel count\&. 
.br
\fItimestamp\fP Optionally the capture time of the most recent sample, in agreement with \fBlocal_clock()\fP; if omitted, the current time is used\&. The time stamps of other samples are automatically derived based on the sampling rate of the stream\&. 
.br
\fIpushthrough\fP Whether to push the chunk through to the receivers instead of buffering it with subsequent samples\&. Note that the chunk_size, if specified at outlet construction, takes precedence over the pushthrough flag\&. 
.RE
.PP

.SS "void lsl::stream_outlet::push_chunk_multiplexed (const double * buffer, std::size_t buffer_elements, double timestamp = \fC0\&.0\fP, bool pushthrough = \fCtrue\fP)\fC [inline]\fP"

.SS "void lsl::stream_outlet::push_chunk_multiplexed (const long * buffer, std::size_t buffer_elements, double timestamp = \fC0\&.0\fP, bool pushthrough = \fCtrue\fP)\fC [inline]\fP"

.SS "void lsl::stream_outlet::push_chunk_multiplexed (const int32_t * buffer, std::size_t buffer_elements, double timestamp = \fC0\&.0\fP, bool pushthrough = \fCtrue\fP)\fC [inline]\fP"

.SS "void lsl::stream_outlet::push_chunk_multiplexed (const int16_t * buffer, std::size_t buffer_elements, double timestamp = \fC0\&.0\fP, bool pushthrough = \fCtrue\fP)\fC [inline]\fP"

.SS "void lsl::stream_outlet::push_chunk_multiplexed (const char * buffer, std::size_t buffer_elements, double timestamp = \fC0\&.0\fP, bool pushthrough = \fCtrue\fP)\fC [inline]\fP"

.SS "void lsl::stream_outlet::push_chunk_multiplexed (const std::string * buffer, std::size_t buffer_elements, double timestamp = \fC0\&.0\fP, bool pushthrough = \fCtrue\fP)\fC [inline]\fP"

.SS "void lsl::stream_outlet::push_chunk_multiplexed (const float * data_buffer, const double * timestamp_buffer, std::size_t data_buffer_elements, bool pushthrough = \fCtrue\fP)\fC [inline]\fP"
Push a chunk of multiplexed samples into the outlet\&. One timestamp per sample is provided\&. IMPORTANT: Note that the provided buffer size is measured in channel values (e\&.g\&., floats) rather than in samples\&. 
.PP
\fBParameters:\fP
.RS 4
\fIdata_buffer\fP A buffer of channel values holding the data for zero or more successive samples to send\&. 
.br
\fItimestamp_buffer\fP A buffer of timestamp values holding time stamps for each sample in the data buffer\&. 
.br
\fIdata_buffer_elements\fP The number of data values (of type T) in the data buffer\&. Must be a multiple of the channel count\&. 
.br
\fIpushthrough\fP Whether to push the chunk through to the receivers instead of buffering it with subsequent samples\&. Note that the chunk_size, if specified at outlet construction, takes precedence over the pushthrough flag\&. 
.RE
.PP

.SS "void lsl::stream_outlet::push_chunk_multiplexed (const double * data_buffer, const double * timestamp_buffer, std::size_t data_buffer_elements, bool pushthrough = \fCtrue\fP)\fC [inline]\fP"

.SS "void lsl::stream_outlet::push_chunk_multiplexed (const long * data_buffer, const double * timestamp_buffer, std::size_t data_buffer_elements, bool pushthrough = \fCtrue\fP)\fC [inline]\fP"

.SS "void lsl::stream_outlet::push_chunk_multiplexed (const int32_t * data_buffer, const double * timestamp_buffer, std::size_t data_buffer_elements, bool pushthrough = \fCtrue\fP)\fC [inline]\fP"

.SS "void lsl::stream_outlet::push_chunk_multiplexed (const int16_t * data_buffer, const double * timestamp_buffer, std::size_t data_buffer_elements, bool pushthrough = \fCtrue\fP)\fC [inline]\fP"

.SS "void lsl::stream_outlet::push_chunk_multiplexed (const char * data_buffer, const double * timestamp_buffer, std::size_t data_buffer_elements, bool pushthrough = \fCtrue\fP)\fC [inline]\fP"

.SS "void lsl::stream_outlet::push_chunk_multiplexed (const std::string * data_buffer, const double * timestamp_buffer, std::size_t data_buffer_elements, bool pushthrough = \fCtrue\fP)\fC [inline]\fP"

.SS "template<class T > void lsl::stream_outlet::push_chunk_numeric_structs (const std::vector< T > & samples, double timestamp = \fC0\&.0\fP, bool pushthrough = \fCtrue\fP)\fC [inline]\fP"
Push a chunk of numeric data as C-style structs (batched into an STL vector) into the outlet\&. This performs some size checking but no type checking\&. Can not be used for variable-size / string-formatted data\&. 
.PP
\fBParameters:\fP
.RS 4
\fIsamples\fP A vector of samples, as C structs\&. 
.br
\fItimestamp\fP Optionally the capture time of the sample, in agreement with \fBlocal_clock()\fP; if omitted, the current time is used\&. 
.br
\fIpushthrough\fP Whether to push the chunk through to the receivers instead of buffering it with subsequent samples\&. Note that the chunk_size, if specified at outlet construction, takes precedence over the pushthrough flag\&. 
.RE
.PP

.SS "template<class T > void lsl::stream_outlet::push_chunk_numeric_structs (const std::vector< T > & samples, const std::vector< double > & timestamps, bool pushthrough = \fCtrue\fP)\fC [inline]\fP"
Push a chunk of numeric data from C-style structs (batched into an STL vector), into the outlet\&. This performs some size checking but no type checking\&. Can not be used for variable-size / string-formatted data\&. 
.PP
\fBParameters:\fP
.RS 4
\fIsamples\fP A vector of samples, as C structs\&. 
.br
\fItimestamps\fP A vector of capture times for each sample, in agreement with \fBlocal_clock()\fP\&. 
.br
\fIpushthrough\fP Whether to push the chunk through to the receivers instead of buffering it with subsequent samples\&. Note that the chunk_size, if specified at outlet construction, takes precedence over the pushthrough flag\&. 
.RE
.PP

.SS "void lsl::stream_outlet::push_numeric_raw (const void * sample, double timestamp = \fC0\&.0\fP, bool pushthrough = \fCtrue\fP)\fC [inline]\fP"
Push a pointer to raw numeric data as one sample into the outlet\&. This is the lowest-level function; performns no checking whatsoever\&. Can not be used for variable-size / string-formatted channels\&. 
.PP
\fBParameters:\fP
.RS 4
\fIsample\fP A pointer to the raw sample data to push\&. 
.br
\fItimestamp\fP Optionally the capture time of the sample, in agreement with \fBlocal_clock()\fP; if omitted, the current time is used\&. 
.br
\fIpushthrough\fP Whether to push the sample through to the receivers instead of buffering it with subsequent samples\&. Note that the chunk_size, if specified at outlet construction, takes precedence over the pushthrough flag\&. 
.RE
.PP

.SS "template<class T > void lsl::stream_outlet::push_numeric_struct (const T & sample, double timestamp = \fC0\&.0\fP, bool pushthrough = \fCtrue\fP)\fC [inline]\fP"
Push a packed C struct (of numeric data) as one sample into the outlet (search for #pragma pack for information on packing structs appropriately)\&. Overall size checking but no type checking or conversion are done\&. Dan not be used for variable-size / string-formatted data\&. 
.PP
\fBParameters:\fP
.RS 4
\fIsample\fP The sample struct to push\&. 
.br
\fItimestamp\fP Optionally the capture time of the sample, in agreement with \fBlocal_clock()\fP; if omitted, the current time is used\&. 
.br
\fIpushthrough\fP Whether to push the sample through to the receivers instead of buffering it with subsequent samples\&. Note that the chunk_size, if specified at outlet construction, takes precedence over the pushthrough flag\&. 
.RE
.PP

.SS "template<class T , int32_t N> void lsl::stream_outlet::push_sample (const T data[N], double timestamp = \fC0\&.0\fP, bool pushthrough = \fCtrue\fP)\fC [inline]\fP"
Push a C array of values as a sample into the outlet\&. Each entry in the array corresponds to one channel\&. The function handles type checking & conversion\&. 
.PP
\fBParameters:\fP
.RS 4
\fIdata\fP An array of values to push (one per channel)\&. 
.br
\fItimestamp\fP Optionally the capture time of the sample, in agreement with \fBlocal_clock()\fP; if omitted, the current time is used\&. 
.br
\fIpushthrough\fP Whether to push the sample through to the receivers instead of buffering it with subsequent samples\&. Note that the chunk_size, if specified at outlet construction, takes precedence over the pushthrough flag\&. 
.RE
.PP

.SS "void lsl::stream_outlet::push_sample (const std::vector< float > & data, double timestamp = \fC0\&.0\fP, bool pushthrough = \fCtrue\fP)\fC [inline]\fP"
Push a std vector of values as a sample into the outlet\&. Each entry in the vector corresponds to one channel\&. The function handles type checking & conversion\&. 
.PP
\fBParameters:\fP
.RS 4
\fIdata\fP A vector of values to push (one for each channel)\&. 
.br
\fItimestamp\fP Optionally the capture time of the sample, in agreement with \fBlocal_clock()\fP; if omitted, the current time is used\&. 
.br
\fIpushthrough\fP Whether to push the sample through to the receivers instead of buffering it with subsequent samples\&. Note that the chunk_size, if specified at outlet construction, takes precedence over the pushthrough flag\&. 
.RE
.PP

.SS "void lsl::stream_outlet::push_sample (const std::vector< double > & data, double timestamp = \fC0\&.0\fP, bool pushthrough = \fCtrue\fP)\fC [inline]\fP"

.SS "void lsl::stream_outlet::push_sample (const std::vector< long > & data, double timestamp = \fC0\&.0\fP, bool pushthrough = \fCtrue\fP)\fC [inline]\fP"

.SS "void lsl::stream_outlet::push_sample (const std::vector< int32_t > & data, double timestamp = \fC0\&.0\fP, bool pushthrough = \fCtrue\fP)\fC [inline]\fP"

.SS "void lsl::stream_outlet::push_sample (const std::vector< int16_t > & data, double timestamp = \fC0\&.0\fP, bool pushthrough = \fCtrue\fP)\fC [inline]\fP"

.SS "void lsl::stream_outlet::push_sample (const std::vector< char > & data, double timestamp = \fC0\&.0\fP, bool pushthrough = \fCtrue\fP)\fC [inline]\fP"

.SS "void lsl::stream_outlet::push_sample (const std::vector< std::string > & data, double timestamp = \fC0\&.0\fP, bool pushthrough = \fCtrue\fP)\fC [inline]\fP"

.SS "void lsl::stream_outlet::push_sample (const float * data, double timestamp = \fC0\&.0\fP, bool pushthrough = \fCtrue\fP)\fC [inline]\fP"
Push a pointer to some values as a sample into the outlet\&. This is a lower-level function for cases where data is available in some buffer\&. Handles type checking & conversion\&. 
.PP
\fBParameters:\fP
.RS 4
\fIdata\fP A pointer to values to push\&. The number of values pointed to must not be less than the number of channels in the sample\&. 
.br
\fItimestamp\fP Optionally the capture time of the sample, in agreement with \fBlocal_clock()\fP; if omitted, the current time is used\&. 
.br
\fIpushthrough\fP Whether to push the sample through to the receivers instead of buffering it with subsequent samples\&. Note that the chunk_size, if specified at outlet construction, takes precedence over the pushthrough flag\&. 
.RE
.PP

.SS "void lsl::stream_outlet::push_sample (const double * data, double timestamp = \fC0\&.0\fP, bool pushthrough = \fCtrue\fP)\fC [inline]\fP"

.SS "void lsl::stream_outlet::push_sample (const long * data, double timestamp = \fC0\&.0\fP, bool pushthrough = \fCtrue\fP)\fC [inline]\fP"

.SS "void lsl::stream_outlet::push_sample (const int32_t * data, double timestamp = \fC0\&.0\fP, bool pushthrough = \fCtrue\fP)\fC [inline]\fP"

.SS "void lsl::stream_outlet::push_sample (const int16_t * data, double timestamp = \fC0\&.0\fP, bool pushthrough = \fCtrue\fP)\fC [inline]\fP"

.SS "void lsl::stream_outlet::push_sample (const char * data, double timestamp = \fC0\&.0\fP, bool pushthrough = \fCtrue\fP)\fC [inline]\fP"

.SS "void lsl::stream_outlet::push_sample (const std::string * data, double timestamp = \fC0\&.0\fP, bool pushthrough = \fCtrue\fP)\fC [inline]\fP"

.SS "bool lsl::stream_outlet::wait_for_consumers (double timeout)\fC [inline]\fP"
Wait until some consumer shows up (without wasting resources)\&. 
.PP
\fBReturns:\fP
.RS 4
True if the wait was successful, false if the timeout expired\&. 
.RE
.PP


.SH "Author"
.PP 
Generated automatically by Doxygen for lslsub_dbfeeder from the source code\&.
