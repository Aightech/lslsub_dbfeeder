.TH "lsl" 3 "Fri May 10 2019" "lslsub_dbfeeder" \" -*- nroff -*-
.ad l
.nh
.SH NAME
lsl
.SH SYNOPSIS
.br
.PP
.SS "Classes"

.in +1c
.ti -1c
.RI "class \fBcontinuous_resolver\fP"
.br
.ti -1c
.RI "class \fBlost_error\fP"
.br
.RI "Exception class that indicates that a stream inlet's source has been irrecoverably lost\&. "
.ti -1c
.RI "class \fBstream_info\fP"
.br
.ti -1c
.RI "class \fBstream_inlet\fP"
.br
.ti -1c
.RI "class \fBstream_outlet\fP"
.br
.ti -1c
.RI "class \fBtimeout_error\fP"
.br
.RI "Exception class that indicates that an operation failed due to a timeout\&. "
.ti -1c
.RI "class \fBxml_element\fP"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef struct lsl_streaminfo_struct_ * \fBlsl_streaminfo\fP"
.br
.ti -1c
.RI "typedef struct lsl_outlet_struct_ * \fBlsl_outlet\fP"
.br
.ti -1c
.RI "typedef struct lsl_inlet_struct_ * \fBlsl_inlet\fP"
.br
.ti -1c
.RI "typedef struct lsl_xml_ptr_struct_ * \fBlsl_xml_ptr\fP"
.br
.ti -1c
.RI "typedef struct lsl_continuous_resolver_ * \fBlsl_continuous_resolver\fP"
.br
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fBlsl_channel_format_t\fP { \fBcft_float32\fP = 1, \fBcft_double64\fP = 2, \fBcft_string\fP = 3, \fBcft_int32\fP = 4, \fBcft_int16\fP = 5, \fBcft_int8\fP = 6, \fBcft_int64\fP = 7, \fBcft_undefined\fP = 0 }"
.br
.ti -1c
.RI "enum \fBlsl_processing_options_t\fP { \fBproc_none\fP = 0, \fBproc_clocksync\fP = 1, \fBproc_dejitter\fP = 2, \fBproc_monotonize\fP = 4, \fBproc_threadsafe\fP = 8, \fBproc_ALL\fP = 1|2|4|8 }"
.br
.ti -1c
.RI "enum \fBlsl_error_code_t\fP { \fBlsl_no_error\fP = 0, \fBlsl_timeout_error\fP = -1, \fBlsl_lost_error\fP = -2, \fBlsl_argument_error\fP = -3, \fBlsl_internal_error\fP = -4 }"
.br
.ti -1c
.RI "enum \fBchannel_format_t\fP { \fBcf_float32\fP = 1, \fBcf_double64\fP = 2, \fBcf_string\fP = 3, \fBcf_int32\fP = 4, \fBcf_int16\fP = 5, \fBcf_int8\fP = 6, \fBcf_int64\fP = 7, \fBcf_undefined\fP = 0 }"
.br
.ti -1c
.RI "enum \fBprocessing_options_t\fP { \fBpost_none\fP = 0, \fBpost_clocksync\fP = 1, \fBpost_dejitter\fP = 2, \fBpost_monotonize\fP = 4, \fBpost_threadsafe\fP = 8, \fBpost_ALL\fP = 1|2|4|8 }"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBLIBLSL_C_API\fP int32_t \fBlsl_protocol_version\fP ()"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP int32_t \fBlsl_library_version\fP ()"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP const char * \fBlsl_library_info\fP ()"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP double \fBlsl_local_clock\fP ()"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP int32_t \fBlsl_resolve_all\fP (\fBlsl_streaminfo\fP *buffer, uint32_t buffer_elements, double wait_time)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP int32_t \fBlsl_resolve_byprop\fP (\fBlsl_streaminfo\fP *buffer, uint32_t buffer_elements, const char *prop, const char *value, int32_t minimum, double timeout)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP int32_t \fBlsl_resolve_bypred\fP (\fBlsl_streaminfo\fP *buffer, uint32_t buffer_elements, const char *pred, int32_t minimum, double timeout)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP void \fBlsl_destroy_string\fP (char *s)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP \fBlsl_streaminfo\fP \fBlsl_create_streaminfo\fP (const char *name, const char *type, int32_t channel_count, double nominal_srate, \fBlsl_channel_format_t\fP channel_format, const char *source_id)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP void \fBlsl_destroy_streaminfo\fP (\fBlsl_streaminfo\fP info)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP \fBlsl_streaminfo\fP \fBlsl_copy_streaminfo\fP (\fBlsl_streaminfo\fP info)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP const char * \fBlsl_get_name\fP (\fBlsl_streaminfo\fP info)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP const char * \fBlsl_get_type\fP (\fBlsl_streaminfo\fP info)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP int32_t \fBlsl_get_channel_count\fP (\fBlsl_streaminfo\fP info)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP double \fBlsl_get_nominal_srate\fP (\fBlsl_streaminfo\fP info)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP \fBlsl_channel_format_t\fP \fBlsl_get_channel_format\fP (\fBlsl_streaminfo\fP info)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP const char * \fBlsl_get_source_id\fP (\fBlsl_streaminfo\fP info)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP int32_t \fBlsl_get_version\fP (\fBlsl_streaminfo\fP info)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP double \fBlsl_get_created_at\fP (\fBlsl_streaminfo\fP info)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP const char * \fBlsl_get_uid\fP (\fBlsl_streaminfo\fP info)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP const char * \fBlsl_get_session_id\fP (\fBlsl_streaminfo\fP info)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP const char * \fBlsl_get_hostname\fP (\fBlsl_streaminfo\fP info)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP \fBlsl_xml_ptr\fP \fBlsl_get_desc\fP (\fBlsl_streaminfo\fP info)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP char * \fBlsl_get_xml\fP (\fBlsl_streaminfo\fP info)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP int32_t \fBlsl_get_channel_bytes\fP (\fBlsl_streaminfo\fP info)"
.br
.RI "Number of bytes occupied by a channel (0 for string-typed channels)\&. "
.ti -1c
.RI "\fBLIBLSL_C_API\fP int32_t \fBlsl_get_sample_bytes\fP (\fBlsl_streaminfo\fP info)"
.br
.RI "Number of bytes occupied by a sample (0 for string-typed channels)\&. "
.ti -1c
.RI "\fBLIBLSL_C_API\fP int \fBlsl_stream_info_matches_query\fP (\fBlsl_streaminfo\fP info, const char *query)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP \fBlsl_streaminfo\fP \fBlsl_streaminfo_from_xml\fP (const char *xml)"
.br
.RI "Create a streaminfo object from an XML representation\&. "
.ti -1c
.RI "\fBLIBLSL_C_API\fP \fBlsl_outlet\fP \fBlsl_create_outlet\fP (\fBlsl_streaminfo\fP info, int32_t chunk_size, int32_t max_buffered)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP void \fBlsl_destroy_outlet\fP (\fBlsl_outlet\fP out)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP int32_t \fBlsl_push_sample_f\fP (\fBlsl_outlet\fP out, const float *data)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP int32_t \fBlsl_push_sample_ft\fP (\fBlsl_outlet\fP out, const float *data, double timestamp)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP int32_t \fBlsl_push_sample_ftp\fP (\fBlsl_outlet\fP out, const float *data, double timestamp, int32_t pushthrough)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP int32_t \fBlsl_push_sample_d\fP (\fBlsl_outlet\fP out, const double *data)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP int32_t \fBlsl_push_sample_dt\fP (\fBlsl_outlet\fP out, const double *data, double timestamp)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP int32_t \fBlsl_push_sample_dtp\fP (\fBlsl_outlet\fP out, const double *data, double timestamp, int32_t pushthrough)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP int32_t \fBlsl_push_sample_l\fP (\fBlsl_outlet\fP out, const long *data)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP int32_t \fBlsl_push_sample_lt\fP (\fBlsl_outlet\fP out, const long *data, double timestamp)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP int32_t \fBlsl_push_sample_ltp\fP (\fBlsl_outlet\fP out, const long *data, double timestamp, int32_t pushthrough)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP int32_t \fBlsl_push_sample_i\fP (\fBlsl_outlet\fP out, const int32_t *data)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP int32_t \fBlsl_push_sample_it\fP (\fBlsl_outlet\fP out, const int32_t *data, double timestamp)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP int32_t \fBlsl_push_sample_itp\fP (\fBlsl_outlet\fP out, const int32_t *data, double timestamp, int32_t pushthrough)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP int32_t \fBlsl_push_sample_s\fP (\fBlsl_outlet\fP out, const int16_t *data)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP int32_t \fBlsl_push_sample_st\fP (\fBlsl_outlet\fP out, const int16_t *data, double timestamp)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP int32_t \fBlsl_push_sample_stp\fP (\fBlsl_outlet\fP out, const int16_t *data, double timestamp, int32_t pushthrough)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP int32_t \fBlsl_push_sample_c\fP (\fBlsl_outlet\fP out, const char *data)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP int32_t \fBlsl_push_sample_ct\fP (\fBlsl_outlet\fP out, const char *data, double timestamp)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP int32_t \fBlsl_push_sample_ctp\fP (\fBlsl_outlet\fP out, const char *data, double timestamp, int32_t pushthrough)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP int32_t \fBlsl_push_sample_str\fP (\fBlsl_outlet\fP out, const char **data)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP int32_t \fBlsl_push_sample_strt\fP (\fBlsl_outlet\fP out, const char **data, double timestamp)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP int32_t \fBlsl_push_sample_strtp\fP (\fBlsl_outlet\fP out, const char **data, double timestamp, int32_t pushthrough)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP int32_t \fBlsl_push_sample_buf\fP (\fBlsl_outlet\fP out, const char **data, const uint32_t *lengths)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP int32_t \fBlsl_push_sample_buft\fP (\fBlsl_outlet\fP out, const char **data, const uint32_t *lengths, double timestamp)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP int32_t \fBlsl_push_sample_buftp\fP (\fBlsl_outlet\fP out, const char **data, const uint32_t *lengths, double timestamp, int32_t pushthrough)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP int32_t \fBlsl_push_sample_v\fP (\fBlsl_outlet\fP out, const void *data)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP int32_t \fBlsl_push_sample_vt\fP (\fBlsl_outlet\fP out, const void *data, double timestamp)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP int32_t \fBlsl_push_sample_vtp\fP (\fBlsl_outlet\fP out, const void *data, double timestamp, int32_t pushthrough)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP int32_t \fBlsl_push_chunk_f\fP (\fBlsl_outlet\fP out, const float *data, unsigned long data_elements)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP int32_t \fBlsl_push_chunk_ft\fP (\fBlsl_outlet\fP out, const float *data, unsigned long data_elements, double timestamp)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP int32_t \fBlsl_push_chunk_ftp\fP (\fBlsl_outlet\fP out, const float *data, unsigned long data_elements, double timestamp, int32_t pushthrough)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP int32_t \fBlsl_push_chunk_ftn\fP (\fBlsl_outlet\fP out, const float *data, unsigned long data_elements, const double *timestamps)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP int32_t \fBlsl_push_chunk_ftnp\fP (\fBlsl_outlet\fP out, const float *data, unsigned long data_elements, const double *timestamps, int32_t pushthrough)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP int32_t \fBlsl_push_chunk_d\fP (\fBlsl_outlet\fP out, const double *data, unsigned long data_elements)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP int32_t \fBlsl_push_chunk_dt\fP (\fBlsl_outlet\fP out, const double *data, unsigned long data_elements, double timestamp)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP int32_t \fBlsl_push_chunk_dtp\fP (\fBlsl_outlet\fP out, const double *data, unsigned long data_elements, double timestamp, int32_t pushthrough)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP int32_t \fBlsl_push_chunk_dtn\fP (\fBlsl_outlet\fP out, const double *data, unsigned long data_elements, const double *timestamps)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP int32_t \fBlsl_push_chunk_dtnp\fP (\fBlsl_outlet\fP out, const double *data, unsigned long data_elements, const double *timestamps, int32_t pushthrough)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP int \fBlsl_push_chunk_l\fP (\fBlsl_outlet\fP out, const long *data, unsigned long data_elements)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP int \fBlsl_push_chunk_lt\fP (\fBlsl_outlet\fP out, const long *data, unsigned long data_elements, double timestamp)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP int \fBlsl_push_chunk_ltp\fP (\fBlsl_outlet\fP out, const long *data, unsigned long data_elements, double timestamp, int pushthrough)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP int \fBlsl_push_chunk_ltn\fP (\fBlsl_outlet\fP out, const long *data, unsigned long data_elements, const double *timestamps)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP int \fBlsl_push_chunk_ltnp\fP (\fBlsl_outlet\fP out, const long *data, unsigned long data_elements, const double *timestamps, int pushthrough)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP int32_t \fBlsl_push_chunk_i\fP (\fBlsl_outlet\fP out, const int32_t *data, unsigned long data_elements)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP int32_t \fBlsl_push_chunk_it\fP (\fBlsl_outlet\fP out, const int32_t *data, unsigned long data_elements, double timestamp)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP int32_t \fBlsl_push_chunk_itp\fP (\fBlsl_outlet\fP out, const int32_t *data, unsigned long data_elements, double timestamp, int32_t pushthrough)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP int32_t \fBlsl_push_chunk_itn\fP (\fBlsl_outlet\fP out, const int32_t *data, unsigned long data_elements, const double *timestamps)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP int32_t \fBlsl_push_chunk_itnp\fP (\fBlsl_outlet\fP out, const int32_t *data, unsigned long data_elements, const double *timestamps, int32_t pushthrough)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP int32_t \fBlsl_push_chunk_s\fP (\fBlsl_outlet\fP out, const int16_t *data, unsigned long data_elements)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP int32_t \fBlsl_push_chunk_st\fP (\fBlsl_outlet\fP out, const int16_t *data, unsigned long data_elements, double timestamp)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP int32_t \fBlsl_push_chunk_stp\fP (\fBlsl_outlet\fP out, const int16_t *data, unsigned long data_elements, double timestamp, int32_t pushthrough)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP int32_t \fBlsl_push_chunk_stn\fP (\fBlsl_outlet\fP out, const int16_t *data, unsigned long data_elements, const double *timestamps)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP int32_t \fBlsl_push_chunk_stnp\fP (\fBlsl_outlet\fP out, const int16_t *data, unsigned long data_elements, const double *timestamps, int32_t pushthrough)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP int32_t \fBlsl_push_chunk_c\fP (\fBlsl_outlet\fP out, const char *data, unsigned long data_elements)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP int32_t \fBlsl_push_chunk_ct\fP (\fBlsl_outlet\fP out, const char *data, unsigned long data_elements, double timestamp)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP int32_t \fBlsl_push_chunk_ctp\fP (\fBlsl_outlet\fP out, const char *data, unsigned long data_elements, double timestamp, int32_t pushthrough)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP int32_t \fBlsl_push_chunk_ctn\fP (\fBlsl_outlet\fP out, const char *data, unsigned long data_elements, const double *timestamps)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP int32_t \fBlsl_push_chunk_ctnp\fP (\fBlsl_outlet\fP out, const char *data, unsigned long data_elements, const double *timestamps, int32_t pushthrough)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP int32_t \fBlsl_push_chunk_str\fP (\fBlsl_outlet\fP out, const char **data, unsigned long data_elements)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP int32_t \fBlsl_push_chunk_strt\fP (\fBlsl_outlet\fP out, const char **data, unsigned long data_elements, double timestamp)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP int32_t \fBlsl_push_chunk_strtp\fP (\fBlsl_outlet\fP out, const char **data, unsigned long data_elements, double timestamp, int32_t pushthrough)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP int32_t \fBlsl_push_chunk_strtn\fP (\fBlsl_outlet\fP out, const char **data, unsigned long data_elements, const double *timestamps)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP int32_t \fBlsl_push_chunk_strtnp\fP (\fBlsl_outlet\fP out, const char **data, unsigned long data_elements, const double *timestamps, int32_t pushthrough)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP int32_t \fBlsl_push_chunk_buf\fP (\fBlsl_outlet\fP out, const char **data, const uint32_t *lengths, unsigned long data_elements)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP int32_t \fBlsl_push_chunk_buft\fP (\fBlsl_outlet\fP out, const char **data, const uint32_t *lengths, unsigned long data_elements, double timestamp)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP int32_t \fBlsl_push_chunk_buftp\fP (\fBlsl_outlet\fP out, const char **data, const uint32_t *lengths, unsigned long data_elements, double timestamp, int32_t pushthrough)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP int32_t \fBlsl_push_chunk_buftn\fP (\fBlsl_outlet\fP out, const char **data, const uint32_t *lengths, unsigned long data_elements, const double *timestamps)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP int32_t \fBlsl_push_chunk_buftnp\fP (\fBlsl_outlet\fP out, const char **data, const uint32_t *lengths, unsigned long data_elements, const double *timestamps, int32_t pushthrough)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP int32_t \fBlsl_have_consumers\fP (\fBlsl_outlet\fP out)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP int32_t \fBlsl_wait_for_consumers\fP (\fBlsl_outlet\fP out, double timeout)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP \fBlsl_streaminfo\fP \fBlsl_get_info\fP (\fBlsl_outlet\fP out)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP \fBlsl_inlet\fP \fBlsl_create_inlet\fP (\fBlsl_streaminfo\fP info, int32_t max_buflen, int32_t max_chunklen, int32_t recover)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP void \fBlsl_destroy_inlet\fP (\fBlsl_inlet\fP in)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP \fBlsl_streaminfo\fP \fBlsl_get_fullinfo\fP (\fBlsl_inlet\fP in, double timeout, int32_t *ec)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP void \fBlsl_open_stream\fP (\fBlsl_inlet\fP in, double timeout, int32_t *ec)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP void \fBlsl_close_stream\fP (\fBlsl_inlet\fP in)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP double \fBlsl_time_correction\fP (\fBlsl_inlet\fP in, double timeout, int32_t *ec)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP double \fBlsl_time_correction_ex\fP (\fBlsl_inlet\fP in, double *remote_time, double *uncertainty, double timeout, int32_t *ec)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP int32_t \fBlsl_set_postprocessing\fP (\fBlsl_inlet\fP in, uint32_t flags)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP double \fBlsl_pull_sample_f\fP (\fBlsl_inlet\fP in, float *buffer, int32_t buffer_elements, double timeout, int32_t *ec)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP double \fBlsl_pull_sample_d\fP (\fBlsl_inlet\fP in, double *buffer, int32_t buffer_elements, double timeout, int32_t *ec)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP double \fBlsl_pull_sample_l\fP (\fBlsl_inlet\fP in, long *buffer, int buffer_elements, double timeout, int *ec)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP double \fBlsl_pull_sample_i\fP (\fBlsl_inlet\fP in, int32_t *buffer, int32_t buffer_elements, double timeout, int32_t *ec)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP double \fBlsl_pull_sample_s\fP (\fBlsl_inlet\fP in, int16_t *buffer, int32_t buffer_elements, double timeout, int32_t *ec)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP double \fBlsl_pull_sample_c\fP (\fBlsl_inlet\fP in, char *buffer, int32_t buffer_elements, double timeout, int32_t *ec)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP double \fBlsl_pull_sample_str\fP (\fBlsl_inlet\fP in, char **buffer, int32_t buffer_elements, double timeout, int32_t *ec)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP double \fBlsl_pull_sample_buf\fP (\fBlsl_inlet\fP in, char **buffer, uint32_t *buffer_lengths, int32_t buffer_elements, double timeout, int32_t *ec)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP double \fBlsl_pull_sample_v\fP (\fBlsl_inlet\fP in, void *buffer, int32_t buffer_bytes, double timeout, int32_t *ec)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP unsigned long \fBlsl_pull_chunk_f\fP (\fBlsl_inlet\fP in, float *data_buffer, double *timestamp_buffer, unsigned long data_buffer_elements, unsigned long timestamp_buffer_elements, double timeout, int32_t *ec)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP unsigned long \fBlsl_pull_chunk_d\fP (\fBlsl_inlet\fP in, double *data_buffer, double *timestamp_buffer, unsigned long data_buffer_elements, unsigned long timestamp_buffer_elements, double timeout, int32_t *ec)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP unsigned long \fBlsl_pull_chunk_l\fP (\fBlsl_inlet\fP in, long *data_buffer, double *timestamp_buffer, unsigned long data_buffer_elements, unsigned long timestamp_buffer_elements, double timeout, int *ec)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP unsigned long \fBlsl_pull_chunk_i\fP (\fBlsl_inlet\fP in, int32_t *data_buffer, double *timestamp_buffer, unsigned long data_buffer_elements, unsigned long timestamp_buffer_elements, double timeout, int32_t *ec)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP unsigned long \fBlsl_pull_chunk_s\fP (\fBlsl_inlet\fP in, int16_t *data_buffer, double *timestamp_buffer, unsigned long data_buffer_elements, unsigned long timestamp_buffer_elements, double timeout, int32_t *ec)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP unsigned long \fBlsl_pull_chunk_c\fP (\fBlsl_inlet\fP in, char *data_buffer, double *timestamp_buffer, unsigned long data_buffer_elements, unsigned long timestamp_buffer_elements, double timeout, int32_t *ec)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP unsigned long \fBlsl_pull_chunk_str\fP (\fBlsl_inlet\fP in, char **data_buffer, double *timestamp_buffer, unsigned long data_buffer_elements, unsigned long timestamp_buffer_elements, double timeout, int32_t *ec)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP unsigned long \fBlsl_pull_chunk_buf\fP (\fBlsl_inlet\fP in, char **data_buffer, uint32_t *lengths_buffer, double *timestamp_buffer, unsigned long data_buffer_elements, unsigned long timestamp_buffer_elements, double timeout, int32_t *ec)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP uint32_t \fBlsl_samples_available\fP (\fBlsl_inlet\fP in)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP uint32_t \fBlsl_was_clock_reset\fP (\fBlsl_inlet\fP in)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP int32_t \fBlsl_smoothing_halftime\fP (\fBlsl_inlet\fP in, float value)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP \fBlsl_xml_ptr\fP \fBlsl_first_child\fP (\fBlsl_xml_ptr\fP e)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP \fBlsl_xml_ptr\fP \fBlsl_last_child\fP (\fBlsl_xml_ptr\fP e)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP \fBlsl_xml_ptr\fP \fBlsl_next_sibling\fP (\fBlsl_xml_ptr\fP e)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP \fBlsl_xml_ptr\fP \fBlsl_previous_sibling\fP (\fBlsl_xml_ptr\fP e)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP \fBlsl_xml_ptr\fP \fBlsl_parent\fP (\fBlsl_xml_ptr\fP e)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP \fBlsl_xml_ptr\fP \fBlsl_child\fP (\fBlsl_xml_ptr\fP e, const char *name)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP \fBlsl_xml_ptr\fP \fBlsl_next_sibling_n\fP (\fBlsl_xml_ptr\fP e, const char *name)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP \fBlsl_xml_ptr\fP \fBlsl_previous_sibling_n\fP (\fBlsl_xml_ptr\fP e, const char *name)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP int32_t \fBlsl_empty\fP (\fBlsl_xml_ptr\fP e)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP int32_t \fBlsl_is_text\fP (\fBlsl_xml_ptr\fP e)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP const char * \fBlsl_name\fP (\fBlsl_xml_ptr\fP e)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP const char * \fBlsl_value\fP (\fBlsl_xml_ptr\fP e)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP const char * \fBlsl_child_value\fP (\fBlsl_xml_ptr\fP e)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP const char * \fBlsl_child_value_n\fP (\fBlsl_xml_ptr\fP e, const char *name)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP \fBlsl_xml_ptr\fP \fBlsl_append_child_value\fP (\fBlsl_xml_ptr\fP e, const char *name, const char *value)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP \fBlsl_xml_ptr\fP \fBlsl_prepend_child_value\fP (\fBlsl_xml_ptr\fP e, const char *name, const char *value)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP int32_t \fBlsl_set_child_value\fP (\fBlsl_xml_ptr\fP e, const char *name, const char *value)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP int32_t \fBlsl_set_name\fP (\fBlsl_xml_ptr\fP e, const char *rhs)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP int32_t \fBlsl_set_value\fP (\fBlsl_xml_ptr\fP e, const char *rhs)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP \fBlsl_xml_ptr\fP \fBlsl_append_child\fP (\fBlsl_xml_ptr\fP e, const char *name)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP \fBlsl_xml_ptr\fP \fBlsl_prepend_child\fP (\fBlsl_xml_ptr\fP e, const char *name)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP \fBlsl_xml_ptr\fP \fBlsl_append_copy\fP (\fBlsl_xml_ptr\fP e, \fBlsl_xml_ptr\fP e2)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP \fBlsl_xml_ptr\fP \fBlsl_prepend_copy\fP (\fBlsl_xml_ptr\fP e, \fBlsl_xml_ptr\fP e2)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP void \fBlsl_remove_child_n\fP (\fBlsl_xml_ptr\fP e, const char *name)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP void \fBlsl_remove_child\fP (\fBlsl_xml_ptr\fP e, \fBlsl_xml_ptr\fP e2)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP \fBlsl_continuous_resolver\fP \fBlsl_create_continuous_resolver\fP (double forget_after)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP \fBlsl_continuous_resolver\fP \fBlsl_create_continuous_resolver_byprop\fP (const char *prop, const char *value, double forget_after)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP \fBlsl_continuous_resolver\fP \fBlsl_create_continuous_resolver_bypred\fP (const char *pred, double forget_after)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP int32_t \fBlsl_resolver_results\fP (\fBlsl_continuous_resolver\fP res, \fBlsl_streaminfo\fP *buffer, uint32_t buffer_elements)"
.br
.ti -1c
.RI "\fBLIBLSL_C_API\fP void \fBlsl_destroy_continuous_resolver\fP (\fBlsl_continuous_resolver\fP res)"
.br
.ti -1c
.RI "int32_t \fBprotocol_version\fP ()"
.br
.ti -1c
.RI "int32_t \fBlibrary_version\fP ()"
.br
.ti -1c
.RI "const char * \fBlibrary_info\fP ()"
.br
.ti -1c
.RI "double \fBlocal_clock\fP ()"
.br
.ti -1c
.RI "std::vector< \fBstream_info\fP > \fBresolve_streams\fP (double wait_time=1\&.0)"
.br
.ti -1c
.RI "std::vector< \fBstream_info\fP > \fBresolve_stream\fP (const std::string &prop, const std::string &value, int32_t minimum=1, double timeout=\fBFOREVER\fP)"
.br
.ti -1c
.RI "std::vector< \fBstream_info\fP > \fBresolve_stream\fP (const std::string &pred, int32_t minimum=1, double timeout=\fBFOREVER\fP)"
.br
.ti -1c
.RI "void \fBcheck_error\fP (int32_t ec)"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "const double \fBIRREGULAR_RATE\fP = 0\&.0"
.br
.ti -1c
.RI "const double \fBDEDUCED_TIMESTAMP\fP = \-1\&.0"
.br
.ti -1c
.RI "const double \fBFOREVER\fP = 32000000\&.0"
.br
.in -1c
.SH "Detailed Description"
.PP 
C++ API for the lab streaming layer\&.
.PP
The lab streaming layer provides a set of functions to make instrument data accessible in real time within a lab network\&. From there, streams can be picked up by recording programs, viewing programs or custom experiment applications that access data streams in real time\&.
.PP
The API covers two areas:
.IP "\(bu" 2
The 'push API' allows to create stream outlets and to push data (regular or irregular measurement time series, event data, coded audio/video frames, etc\&.) into them\&.
.IP "\(bu" 2
The 'pull API' allows to create stream inlets and read time-synched experiment data from them (for recording, viewing or experiment control)\&.
.PP
.PP
To use this library you need to link to either the liblsl32 or liblsl64 shared library that comes with this header\&. Under Visual Studio the library is linked in automatically\&. 
.SH "Typedef Documentation"
.PP 
.SS "typedef struct lsl_continuous_resolver_* \fBlsl::lsl_continuous_resolver\fP"
Handle to a convenience object that resolves streams continuously in the background throughout its lifetime and which can be queried at any time for the set of streams that are currently visible on the network\&. 
.SS "typedef struct lsl_inlet_struct_* \fBlsl::lsl_inlet\fP"
A stream inlet handle\&. Inlets are used to receive streaming data (and meta-data) from the lab network\&. 
.SS "typedef struct lsl_outlet_struct_* \fBlsl::lsl_outlet\fP"
A stream outlet handle\&. Outlets are used to make streaming data (and the meta-data) available on the lab network\&. 
.SS "typedef struct lsl_streaminfo_struct_* \fBlsl::lsl_streaminfo\fP"
Handle to a stream info object\&. Stores the declaration of a data stream\&. Represents the following information: a) stream data format (#channels, channel format) b) core information (stream name, content type, sampling rate) c) optional meta-data about the stream content (channel labels, measurement units, etc\&.)
.PP
Whenever a program wants to provide a new stream on the lab network it will typically first create an lsl_streaminfo to describe its properties and then construct an lsl_outlet with it to create the stream on the network\&. Other parties who discover/resolve the outlet on the network can query the stream info; it is also written to disk when recording the stream (playing a similar role as a file header)\&. 
.SS "typedef struct lsl_xml_ptr_struct_* \fBlsl::lsl_xml_ptr\fP"
A lightweight XML element tree handle; models the description of a streaminfo object\&. XML elements behave like advanced pointers into memory that is owned by some respective streaminfo\&. Has a name and can have multiple named children or have text content as value; attributes are omitted\&. Insider note: The interface is modeled after a subset of pugixml's node type and is compatible with it\&. Type-casts between pugi::xml_node_struct* and lsl_xml_ptr are permitted (in both directions) since the types are binary compatible\&. See also pugixml\&.googlecode\&.com/svn/tags/latest/docs/manual/access\&.html for additional documentation\&. 
.SH "Enumeration Type Documentation"
.PP 
.SS "enum \fBlsl::channel_format_t\fP"
Data format of a channel (each transmitted sample holds an array of channels)\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIcf_float32 \fP\fP
.TP
\fB\fIcf_double64 \fP\fP
.TP
\fB\fIcf_string \fP\fP
.TP
\fB\fIcf_int32 \fP\fP
.TP
\fB\fIcf_int16 \fP\fP
.TP
\fB\fIcf_int8 \fP\fP
.TP
\fB\fIcf_int64 \fP\fP
.TP
\fB\fIcf_undefined \fP\fP
.SS "enum \fBlsl::lsl_channel_format_t\fP"
Data format of a channel (each transmitted sample holds an array of channels)\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIcft_float32 \fP\fP
.TP
\fB\fIcft_double64 \fP\fP
.TP
\fB\fIcft_string \fP\fP
.TP
\fB\fIcft_int32 \fP\fP
.TP
\fB\fIcft_int16 \fP\fP
.TP
\fB\fIcft_int8 \fP\fP
.TP
\fB\fIcft_int64 \fP\fP
.TP
\fB\fIcft_undefined \fP\fP
.SS "enum \fBlsl::lsl_error_code_t\fP"
Possible error codes\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIlsl_no_error \fP\fP
.TP
\fB\fIlsl_timeout_error \fP\fP
.TP
\fB\fIlsl_lost_error \fP\fP
.TP
\fB\fIlsl_argument_error \fP\fP
.TP
\fB\fIlsl_internal_error \fP\fP
.SS "enum \fBlsl::lsl_processing_options_t\fP"
Post-processing options for stream inlets\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIproc_none \fP\fP
.TP
\fB\fIproc_clocksync \fP\fP
.TP
\fB\fIproc_dejitter \fP\fP
.TP
\fB\fIproc_monotonize \fP\fP
.TP
\fB\fIproc_threadsafe \fP\fP
.TP
\fB\fIproc_ALL \fP\fP
.SS "enum \fBlsl::processing_options_t\fP"
Post-processing options for stream inlets\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIpost_none \fP\fP
.TP
\fB\fIpost_clocksync \fP\fP
.TP
\fB\fIpost_dejitter \fP\fP
.TP
\fB\fIpost_monotonize \fP\fP
.TP
\fB\fIpost_threadsafe \fP\fP
.TP
\fB\fIpost_ALL \fP\fP
.SH "Function Documentation"
.PP 
.SS "void lsl::check_error (int32_t ec)\fC [inline]\fP"
A stream inlet\&. Inlets are used to receive streaming data (and meta-data) from the lab network\&.
.PP
Check error codes returned from the C interface and translate into appropriate exceptions\&. 
.SS "const char* lsl::library_info ()\fC [inline]\fP"
Get a string containing library information\&. The format of the string shouldn't be used for anything important except giving a a debugging person a good idea which exact library version is used\&. 
.SS "int32_t lsl::library_version ()\fC [inline]\fP"
Version of the liblsl library\&. The major version is \fBlibrary_version()\fP / 100; The minor version is \fBlibrary_version()\fP % 100; 
.SS "double lsl::local_clock ()\fC [inline]\fP"
Obtain a local system time stamp in seconds\&. The resolution is better than a millisecond\&. This reading can be used to assign time stamps to samples as they are being acquired\&. If the 'age' of a sample is known at a particular time (e\&.g\&., from USB transmission delays), it can be used as an offset to \fBlocal_clock()\fP to obtain a better estimate of when a sample was actually captured\&. See \fBstream_outlet::push_sample()\fP for a use case\&. 
.SS "\fBLIBLSL_C_API\fP \fBlsl_xml_ptr\fP lsl::lsl_append_child (\fBlsl_xml_ptr\fP e, const char * name)"
Append a child element with the specified name\&. 
.SS "\fBLIBLSL_C_API\fP \fBlsl_xml_ptr\fP lsl::lsl_append_child_value (\fBlsl_xml_ptr\fP e, const char * name, const char * value)"
Append a child node with a given name, which has a (nameless) plain-text child with the given text value\&. 
.SS "\fBLIBLSL_C_API\fP \fBlsl_xml_ptr\fP lsl::lsl_append_copy (\fBlsl_xml_ptr\fP e, \fBlsl_xml_ptr\fP e2)"
Append a copy of the specified element as a child\&. 
.SS "\fBLIBLSL_C_API\fP \fBlsl_xml_ptr\fP lsl::lsl_child (\fBlsl_xml_ptr\fP e, const char * name)"
Get a child with a specified name\&. 
.SS "\fBLIBLSL_C_API\fP const char* lsl::lsl_child_value (\fBlsl_xml_ptr\fP e)"
Get child value (value of the first child that is text)\&. 
.SS "\fBLIBLSL_C_API\fP const char* lsl::lsl_child_value_n (\fBlsl_xml_ptr\fP e, const char * name)"
Get child value of a child with a specified name\&. 
.SS "\fBLIBLSL_C_API\fP void lsl::lsl_close_stream (\fBlsl_inlet\fP in)"
Drop the current data stream\&. All samples that are still buffered or in flight will be dropped and transmission and buffering of data for this inlet will be stopped\&. If an application stops being interested in data from a source (temporarily or not) but keeps the outlet alive, it should call \fBlsl_close_stream()\fP to not waste unnecessary system and network resources\&. 
.SS "\fBLIBLSL_C_API\fP \fBlsl_streaminfo\fP lsl::lsl_copy_streaminfo (\fBlsl_streaminfo\fP info)"
Copy an existing streaminfo object (rarely used)\&. 
.SS "\fBLIBLSL_C_API\fP \fBlsl_continuous_resolver\fP lsl::lsl_create_continuous_resolver (double forget_after)"
Construct a new \fBcontinuous_resolver\fP that resolves all streams on the network\&. This is analogous to the functionality offered by the free function \fBresolve_streams()\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIforget_after\fP When a stream is no longer visible on the network (e\&.g\&., because it was shut down), this is the time in seconds after which it is no longer reported by the resolver\&. The recommended default value is 5\&.0\&. 
.RE
.PP

.SS "\fBLIBLSL_C_API\fP \fBlsl_continuous_resolver\fP lsl::lsl_create_continuous_resolver_bypred (const char * pred, double forget_after)"
Construct a new \fBcontinuous_resolver\fP that resolves all streams that match a given XPath 1\&.0 predicate\&. This is analogous to the functionality provided by the free function resolve_stream(pred)\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpred\fP The predicate string, e\&.g\&. 'name='BioSemi'' or 'type='EEG' and starts-with(name,'BioSemi') and count(info/desc/channel)=32' 
.br
\fIforget_after\fP When a stream is no longer visible on the network (e\&.g\&., because it was shut down), this is the time in seconds after which it is no longer reported by the resolver\&. The recommended default value is 5\&.0\&. 
.RE
.PP

.SS "\fBLIBLSL_C_API\fP \fBlsl_continuous_resolver\fP lsl::lsl_create_continuous_resolver_byprop (const char * prop, const char * value, double forget_after)"
Construct a new \fBcontinuous_resolver\fP that resolves all streams with a specific value for a given property\&. This is analogous to the functionality provided by the free function resolve_stream(prop,value)\&. 
.PP
\fBParameters:\fP
.RS 4
\fIprop\fP The \fBstream_info\fP property that should have a specific value (e\&.g\&., 'name', 'type', 'source_id', or 'desc/manufaturer')\&. 
.br
\fIvalue\fP The string value that the property should have (e\&.g\&., 'EEG' as the type property)\&. 
.br
\fIforget_after\fP When a stream is no longer visible on the network (e\&.g\&., because it was shut down), this is the time in seconds after which it is no longer reported by the resolver\&. The recommended default value is 5\&.0\&. 
.RE
.PP

.SS "\fBLIBLSL_C_API\fP \fBlsl_inlet\fP lsl::lsl_create_inlet (\fBlsl_streaminfo\fP info, int32_t max_buflen, int32_t max_chunklen, int32_t recover)"
Construct a new stream inlet from a resolved stream info\&. 
.PP
\fBParameters:\fP
.RS 4
\fIinfo\fP A resolved stream info object (as coming from one of the resolver functions)\&. Note: the inlet makes a copy of the info object at its construction\&. Note: the \fBstream_inlet\fP may also be constructed with a fully-specified \fBstream_info\fP, if the desired channel format and count is already known up-front, but this is strongly discouraged and should only ever be done if there is no time to resolve the stream up-front (e\&.g\&., due to limitations in the client program)\&. 
.br
\fImax_buflen\fP Optionally the maximum amount of data to buffer (in seconds if there is a nominal sampling rate, otherwise x100 in samples)\&. Recording applications want to use a fairly large buffer size here, while real-time applications would only buffer as much as they need to perform their next calculation\&. A good default is 360, which corresponds to 6 minutes of data\&. 
.br
\fImax_chunklen\fP Optionally the maximum size, in samples, at which chunks are transmitted\&. If specified as 0, the chunk sizes preferred by the sender are used\&. Recording applications can use a generous size here (leaving it to the network how to pack things), while real-time applications may want a finer (perhaps 1-sample) granularity\&. 
.br
\fIrecover\fP Try to silently recover lost streams that are recoverable (=those that that have a source_id set)\&. It is generally a good idea to enable this, unless the application wants to act in a special way when a data provider has temporarily crashed\&. If recover is 0 or the stream is not recoverable, most outlet functions will return an lsl_lost_error if the stream's source is lost\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
A newly created lsl_inlet handle or NULL in the event that an error occurred\&. 
.RE
.PP

.SS "\fBLIBLSL_C_API\fP \fBlsl_outlet\fP lsl::lsl_create_outlet (\fBlsl_streaminfo\fP info, int32_t chunk_size, int32_t max_buffered)"
Establish a new stream outlet\&. This makes the stream discoverable\&. 
.PP
\fBParameters:\fP
.RS 4
\fIinfo\fP The stream information to use for creating this stream\&. Stays constant over the lifetime of the outlet\&. Note: the outlet makes a copy of the streaminfo object upon construction (so the old info should still be destroyed\&.) 
.br
\fIchunk_size\fP Optionally the desired chunk granularity (in samples) for transmission\&. If specified as 0, each push operation yields one chunk\&. Stream recipients can have this setting bypassed\&. 
.br
\fImax_buffered\fP Optionally the maximum amount of data to buffer (in seconds if there is a nominal sampling rate, otherwise x100 in samples)\&. A good default is 360, which corresponds to 6 minutes of data\&. Note that, for high-bandwidth data you will almost certainly want to use a lower value here to avoid running out of RAM\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
A newly created lsl_outlet handle or NULL in the event that an error occurred\&. 
.RE
.PP

.SS "\fBLIBLSL_C_API\fP \fBlsl_streaminfo\fP lsl::lsl_create_streaminfo (const char * name, const char * type, int32_t channel_count, double nominal_srate, \fBlsl_channel_format_t\fP channel_format, const char * source_id)"
Construct a new streaminfo object\&. Core stream information is specified here\&. Any remaining meta-data can be added later\&. 
.PP
\fBParameters:\fP
.RS 4
\fIname\fP Name of the stream\&. Describes the device (or product series) that this stream makes available (for use by programs, experimenters or data analysts)\&. Cannot be empty\&. 
.br
\fItype\fP Content type of the stream\&. Please see https://github.com/sccn/xdf/wiki/Meta-Data (or web search for: XDF meta-data) for pre-defined content-type names, but you can also make up your own\&. The content type is the preferred way to find streams (as opposed to searching by name)\&. 
.br
\fIchannel_count\fP Number of channels per sample\&. This stays constant for the lifetime of the stream\&. 
.br
\fInominal_srate\fP The sampling rate (in Hz) as advertised by the data source, if regular (otherwise set to IRREGULAR_RATE)\&. 
.br
\fIchannel_format\fP Format/type of each channel\&. If your channels have different formats, consider supplying multiple streams or use the largest type that can hold them all (such as cft_double64)\&. A good default is cft_float32\&. 
.br
\fIsource_id\fP Unique identifier of the source or device, if available (such as the serial number)\&. Allows recipients to recover from failure even after the serving app or device crashes\&. May in some cases also be constructed from device settings\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
A newly created streaminfo handle or NULL in the event that an error occurred\&. 
.RE
.PP

.SS "\fBLIBLSL_C_API\fP void lsl::lsl_destroy_continuous_resolver (\fBlsl_continuous_resolver\fP res)"
Destructor for the continuous resolver\&. 
.SS "\fBLIBLSL_C_API\fP void lsl::lsl_destroy_inlet (\fBlsl_inlet\fP in)"
Destructor\&. The inlet will automatically disconnect if destroyed\&. 
.SS "\fBLIBLSL_C_API\fP void lsl::lsl_destroy_outlet (\fBlsl_outlet\fP out)"
Destroy an outlet\&. The outlet will no longer be discoverable after destruction and all connected inlets will stop delivering data\&. 
.SS "\fBLIBLSL_C_API\fP void lsl::lsl_destroy_streaminfo (\fBlsl_streaminfo\fP info)"
Destroy a previously created streaminfo object\&. 
.SS "\fBLIBLSL_C_API\fP void lsl::lsl_destroy_string (char * s)"
Deallocate a string that has been transferred to the application\&. Rarely used: the only use case is to deallocate the contents of string-valued samples received from LSL in an application where no free() method is available (e\&.g\&., in some scripting languages)\&. 
.SS "\fBLIBLSL_C_API\fP int32_t lsl::lsl_empty (\fBlsl_xml_ptr\fP e)"
Whether this node is empty\&. 
.SS "\fBLIBLSL_C_API\fP \fBlsl_xml_ptr\fP lsl::lsl_first_child (\fBlsl_xml_ptr\fP e)"
Get the first child of the element\&. 
.SS "\fBLIBLSL_C_API\fP int32_t lsl::lsl_get_channel_bytes (\fBlsl_streaminfo\fP info)"

.PP
Number of bytes occupied by a channel (0 for string-typed channels)\&. 
.SS "\fBLIBLSL_C_API\fP int32_t lsl::lsl_get_channel_count (\fBlsl_streaminfo\fP info)"
Number of channels of the stream\&. A stream has at least one channels; the channel count stays constant for all samples\&. 
.SS "\fBLIBLSL_C_API\fP \fBlsl_channel_format_t\fP lsl::lsl_get_channel_format (\fBlsl_streaminfo\fP info)"
Channel format of the stream\&. All channels in a stream have the same format\&. However, a device might offer multiple time-synched streams each with its own format\&. 
.SS "\fBLIBLSL_C_API\fP double lsl::lsl_get_created_at (\fBlsl_streaminfo\fP info)"
Creation time stamp of the stream\&. This is the time stamp when the stream was first created (as determined via \fBlocal_clock()\fP on the providing machine)\&. 
.SS "\fBLIBLSL_C_API\fP \fBlsl_xml_ptr\fP lsl::lsl_get_desc (\fBlsl_streaminfo\fP info)"
Extended description of the stream\&. It is highly recommended that at least the channel labels are described here\&. See code examples on the LSL wiki\&. Other information, such as amplifier settings, measurement units if deviating from defaults, setup information, subject information, etc\&., can be specified here, as well\&. Meta-data recommendations follow the XDF file format project (github\&.com/sccn/xdf/wiki/Meta-Data or web search for: XDF meta-data)\&.
.PP
Important: if you use a stream content type for which meta-data recommendations exist, please try to lay out your meta-data in agreement with these recommendations for compatibility with other applications\&. 
.SS "\fBLIBLSL_C_API\fP \fBlsl_streaminfo\fP lsl::lsl_get_fullinfo (\fBlsl_inlet\fP in, double timeout, int32_t * ec)"
Retrieve the complete information of the given stream, including the extended description\&. Can be invoked at any time of the stream's lifetime\&. 
.PP
\fBParameters:\fP
.RS 4
\fIin\fP The lsl_inlet object to act on\&. 
.br
\fItimeout\fP Timeout of the operation\&. Use LSL_FOREVER to effectively disable it\&. 
.br
\fIec\fP Error code: if nonzero, can be either lsl_timeout_error (if the timeout has expired) or lsl_lost_error (if the stream source has been lost)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
A copy of the full streaminfo of the inlet or NULL in the event that an error happened\&. Note: it is the user's responsibility to destroy it when it is no longer needed\&. 
.RE
.PP

.SS "\fBLIBLSL_C_API\fP const char* lsl::lsl_get_hostname (\fBlsl_streaminfo\fP info)"
Hostname of the providing machine (once bound to an outlet)\&. Modification is not permitted\&. 
.SS "\fBLIBLSL_C_API\fP \fBlsl_streaminfo\fP lsl::lsl_get_info (\fBlsl_outlet\fP out)"
Retrieve a handle to the stream info provided by this outlet\&. This is what was used to create the stream (and also has the Additional Network Information fields assigned)\&. 
.PP
\fBReturns:\fP
.RS 4
A copy of the streaminfo of the outlet or NULL in the event that an error occurred\&. Note: it is the user's responsibility to destroy it when it is no longer needed\&. 
.RE
.PP

.SS "\fBLIBLSL_C_API\fP const char* lsl::lsl_get_name (\fBlsl_streaminfo\fP info)"
Name of the stream\&. This is a human-readable name\&. For streams offered by device modules, it refers to the type of device or product series that is generating the data of the stream\&. If the source is an application, the name may be a more generic or specific identifier\&. Multiple streams with the same name can coexist, though potentially at the cost of ambiguity (for the recording app or experimenter)\&. 
.PP
\fBReturns:\fP
.RS 4
A library-owned pointer to the string value\&. Modification is not permitted\&. 
.RE
.PP

.SS "\fBLIBLSL_C_API\fP double lsl::lsl_get_nominal_srate (\fBlsl_streaminfo\fP info)"
Sampling rate of the stream, according to the source (in Hz)\&. If a stream is irregularly sampled, this should be set to IRREGULAR_RATE\&.
.PP
Note that no data will be lost even if this sampling rate is incorrect or if a device has temporary hiccups, since all samples will be recorded anyway (except for those dropped by the device itself)\&. However, when the recording is imported into an application, a good importer may correct such errors more accurately if the advertised sampling rate was close to the specs of the device\&. 
.SS "\fBLIBLSL_C_API\fP int32_t lsl::lsl_get_sample_bytes (\fBlsl_streaminfo\fP info)"

.PP
Number of bytes occupied by a sample (0 for string-typed channels)\&. 
.SS "\fBLIBLSL_C_API\fP const char* lsl::lsl_get_session_id (\fBlsl_streaminfo\fP info)"
Session ID for the given stream\&. The session id is an optional human-assigned identifier of the recording session\&. While it is rarely used, it can be used to prevent concurrent recording activitites on the same sub-network (e\&.g\&., in multiple experiment areas) from seeing each other's streams (assigned via a configuration file by the experimenter, see Network Connectivity on the LSL wiki)\&. 
.PP
\fBReturns:\fP
.RS 4
A library-owned pointer to the string value\&. Modification is not permitted\&. 
.RE
.PP

.SS "\fBLIBLSL_C_API\fP const char* lsl::lsl_get_source_id (\fBlsl_streaminfo\fP info)"
Unique identifier of the stream's source, if available\&. The unique source (or device) identifier is an optional piece of information that, if available, allows that endpoints (such as the recording program) can re-acquire a stream automatically once it is back online\&. 
.PP
\fBReturns:\fP
.RS 4
A library-owned pointer to the string value\&. Modification is not permitted\&. 
.RE
.PP

.SS "\fBLIBLSL_C_API\fP const char* lsl::lsl_get_type (\fBlsl_streaminfo\fP info)"
Content type of the stream\&. The content type is a short string such as 'EEG', 'Gaze' which describes the content carried by the channel (if known)\&. If a stream contains mixed content this value need not be assigned but may instead be stored in the description of channel types\&. To be useful to applications and automated processing systems using the recommended content types is preferred\&. Content types usually follow those pre-defined in https://github.com/sccn/xdf/wiki/Meta-Data (or web search for: XDF meta-data)\&. 
.PP
\fBReturns:\fP
.RS 4
A library-owned pointer to the string value\&. Modification is not permitted\&. 
.RE
.PP

.SS "\fBLIBLSL_C_API\fP const char* lsl::lsl_get_uid (\fBlsl_streaminfo\fP info)"
Unique ID of the stream outlet (once assigned)\&. This is a unique identifier of the stream outlet, and is guaranteed to be different across multiple instantiations of the same outlet (e\&.g\&., after a re-start)\&. 
.PP
\fBReturns:\fP
.RS 4
A library-owned pointer to the string value\&. Modification is not permitted\&. 
.RE
.PP

.SS "\fBLIBLSL_C_API\fP int32_t lsl::lsl_get_version (\fBlsl_streaminfo\fP info)"
Protocol version used to deliver the stream\&. 
.SS "\fBLIBLSL_C_API\fP char* lsl::lsl_get_xml (\fBlsl_streaminfo\fP info)"
Retrieve the entire streaminfo in XML format\&. This yields an XML document (in string form) whose top-level element is <info>\&. The info element contains one element for each field of the streaminfo class, including: a) the core elements <name>, <type>, <channel_count>, <nominal_srate>, <channel_format>, <source_id> b) the misc elements <version>, <created_at>, <uid>, <session_id>, <v4address>, <v4data_port>, <v4service_port>, <v6address>, <v6data_port>, <v6service_port> c) the extended description element <desc> with user-defined sub-elements\&. 
.PP
\fBReturns:\fP
.RS 4
A pointer to a copy of the XML text or NULL in the event that an error occurred\&. Note: It is the user's responsibility to deallocate this string when it is no longer needed\&. 
.RE
.PP

.SS "\fBLIBLSL_C_API\fP int32_t lsl::lsl_have_consumers (\fBlsl_outlet\fP out)"
Check whether consumers are currently registered\&. While it does not hurt, there is technically no reason to push samples if there is no consumer\&. 
.SS "\fBLIBLSL_C_API\fP int32_t lsl::lsl_is_text (\fBlsl_xml_ptr\fP e)"
Whether this is a text body (instead of an XML element)\&. True both for plain char data and CData\&. 
.SS "\fBLIBLSL_C_API\fP \fBlsl_xml_ptr\fP lsl::lsl_last_child (\fBlsl_xml_ptr\fP e)"
Get the last child of the element\&. 
.SS "\fBLIBLSL_C_API\fP const char* lsl::lsl_library_info ()"
Get a string containing library information\&. The format of the string shouldn't be used for anything important except giving a a debugging person a good idea which exact library version is used\&. 
.SS "\fBLIBLSL_C_API\fP int32_t lsl::lsl_library_version ()"
Version of the liblsl library\&. The major version is \fBlibrary_version()\fP / 100; The minor version is \fBlibrary_version()\fP % 100; 
.SS "\fBLIBLSL_C_API\fP double lsl::lsl_local_clock ()"
Obtain a local system time stamp in seconds\&. The resolution is better than a millisecond\&. This reading can be used to assign time stamps to samples as they are being acquired\&. If the 'age' of a sample is known at a particular time (e\&.g\&., from USB transmission delays), it can be used as an offset to \fBlsl_local_clock()\fP to obtain a better estimate of when a sample was actually captured\&. See lsl_push_sample() for a use case\&. 
.SS "\fBLIBLSL_C_API\fP const char* lsl::lsl_name (\fBlsl_xml_ptr\fP e)"
Name of the element\&. 
.SS "\fBLIBLSL_C_API\fP \fBlsl_xml_ptr\fP lsl::lsl_next_sibling (\fBlsl_xml_ptr\fP e)"
Get the next sibling in the children list of the parent node\&. 
.SS "\fBLIBLSL_C_API\fP \fBlsl_xml_ptr\fP lsl::lsl_next_sibling_n (\fBlsl_xml_ptr\fP e, const char * name)"
Get the next sibling with the specified name\&. 
.SS "\fBLIBLSL_C_API\fP void lsl::lsl_open_stream (\fBlsl_inlet\fP in, double timeout, int32_t * ec)"
Subscribe to the data stream\&. All samples pushed in at the other end from this moment onwards will be queued and eventually be delivered in response to pull_sample() calls\&. Pulling a sample without some preceding \fBlsl_open_stream()\fP is permitted (the stream will then be opened implicitly)\&. 
.PP
\fBParameters:\fP
.RS 4
\fIin\fP The lsl_inlet object to act on\&. 
.br
\fItimeout\fP Optional timeout of the operation\&. Use LSL_FOREVER to effectively disable it\&. 
.br
\fIec\fP Error code: if nonzero, can be either lsl_timeout_error (if the timeout has expired) or lsl_lost_error (if the stream source has been lost)\&. 
.RE
.PP

.SS "\fBLIBLSL_C_API\fP \fBlsl_xml_ptr\fP lsl::lsl_parent (\fBlsl_xml_ptr\fP e)"
Get the parent node\&. 
.SS "\fBLIBLSL_C_API\fP \fBlsl_xml_ptr\fP lsl::lsl_prepend_child (\fBlsl_xml_ptr\fP e, const char * name)"
Prepend a child element with the specified name\&. 
.SS "\fBLIBLSL_C_API\fP \fBlsl_xml_ptr\fP lsl::lsl_prepend_child_value (\fBlsl_xml_ptr\fP e, const char * name, const char * value)"
Prepend a child node with a given name, which has a (nameless) plain-text child with the given text value\&. 
.SS "\fBLIBLSL_C_API\fP \fBlsl_xml_ptr\fP lsl::lsl_prepend_copy (\fBlsl_xml_ptr\fP e, \fBlsl_xml_ptr\fP e2)"
Prepend a child element with the specified name\&. 
.SS "\fBLIBLSL_C_API\fP \fBlsl_xml_ptr\fP lsl::lsl_previous_sibling (\fBlsl_xml_ptr\fP e)"
Get the previous sibling in the children list of the parent node\&. 
.SS "\fBLIBLSL_C_API\fP \fBlsl_xml_ptr\fP lsl::lsl_previous_sibling_n (\fBlsl_xml_ptr\fP e, const char * name)"
Get the previous sibling with the specified name\&. 
.SS "\fBLIBLSL_C_API\fP int32_t lsl::lsl_protocol_version ()"
Protocol version\&. The major version is \fBprotocol_version()\fP / 100; The minor version is \fBprotocol_version()\fP % 100; Clients with different minor versions are protocol-compatible with each other while clients with different major versions will refuse to work together\&. 
.SS "\fBLIBLSL_C_API\fP unsigned long lsl::lsl_pull_chunk_buf (\fBlsl_inlet\fP in, char ** data_buffer, uint32_t * lengths_buffer, double * timestamp_buffer, unsigned long data_buffer_elements, unsigned long timestamp_buffer_elements, double timeout, int32_t * ec)"
Pull a chunk of data from the inlet and read it into an array of binary strings\&. These strings may contains 0's, therefore the lengths are read into the lengths_buffer array\&. Handles type checking & conversion\&. IMPORTANT: Note that the provided data buffer size is measured in channel values (e\&.g\&., floats) rather than in samples\&. 
.PP
\fBParameters:\fP
.RS 4
\fIin\fP The lsl_inlet object to act on\&. 
.br
\fIdata_buffer\fP A pointer to a buffer of data values where the results shall be stored\&. 
.br
\fIlengths_buffer\fP A pointer to an array that holds the resulting lengths for each returned binary string\&. 
.br
\fItimestamp_buffer\fP A pointer to a buffer of timestamp values where time stamps shall be stored\&. If this is NULL, no time stamps will be returned\&. 
.br
\fIdata_buffer_elements\fP The size of the data buffer, in channel data elements (of type T)\&. Must be a multiple of the stream's channel count\&. 
.br
\fItimestamp_buffer_elements\fP The size of the timestamp buffer\&. If a timestamp buffer is provided then this must correspond to the same number of samples as data_buffer_elements\&. 
.br
\fItimeout\fP The timeout for this operation, if any\&. When the timeout expires, the function may return before the entire buffer is filled\&. The default value of 0\&.0 will retrieve only data available for immediate pickup\&. 
.br
\fIec\fP Error code: can be either no error or lsl_lost_error (if the stream source has been lost)\&. Note: if the timeout expires before a new sample was received the function returns 0\&.0; ec is \fInot\fP set to lsl_timeout_error (because this case is not considered an error condition)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
data_elements_written Number of channel data elements written to the data buffer\&. 
.RE
.PP

.SS "\fBLIBLSL_C_API\fP unsigned long lsl::lsl_pull_chunk_c (\fBlsl_inlet\fP in, char * data_buffer, double * timestamp_buffer, unsigned long data_buffer_elements, unsigned long timestamp_buffer_elements, double timeout, int32_t * ec)"

.SS "\fBLIBLSL_C_API\fP unsigned long lsl::lsl_pull_chunk_d (\fBlsl_inlet\fP in, double * data_buffer, double * timestamp_buffer, unsigned long data_buffer_elements, unsigned long timestamp_buffer_elements, double timeout, int32_t * ec)"

.SS "\fBLIBLSL_C_API\fP unsigned long lsl::lsl_pull_chunk_f (\fBlsl_inlet\fP in, float * data_buffer, double * timestamp_buffer, unsigned long data_buffer_elements, unsigned long timestamp_buffer_elements, double timeout, int32_t * ec)"
Pull a chunk of data from the inlet and read it into a buffer\&. Handles type checking & conversion\&. IMPORTANT: Note that the provided data buffer size is measured in channel values (e\&.g\&., floats) rather than in samples\&. 
.PP
\fBParameters:\fP
.RS 4
\fIin\fP The lsl_inlet object to act on\&. 
.br
\fIdata_buffer\fP A pointer to a buffer of data values where the results shall be stored\&. 
.br
\fItimestamp_buffer\fP A pointer to a buffer of timestamp values where time stamps shall be stored\&. If this is NULL, no time stamps will be returned\&. 
.br
\fIdata_buffer_elements\fP The size of the data buffer, in channel data elements (of type T)\&. Must be a multiple of the stream's channel count\&. 
.br
\fItimestamp_buffer_elements\fP The size of the timestamp buffer\&. If a timestamp buffer is provided then this must correspond to the same number of samples as data_buffer_elements\&. 
.br
\fItimeout\fP The timeout for this operation, if any\&. When the timeout expires, the function may return before the entire buffer is filled\&. The default value of 0\&.0 will retrieve only data available for immediate pickup\&. 
.br
\fIec\fP Error code: can be either no error or lsl_lost_error (if the stream source has been lost)\&. Note: if the timeout expires before a new sample was received the function returns 0\&.0; ec is \fInot\fP set to lsl_timeout_error (because this case is not considered an error condition)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
data_elements_written Number of channel data elements written to the data buffer\&. 
.RE
.PP

.SS "\fBLIBLSL_C_API\fP unsigned long lsl::lsl_pull_chunk_i (\fBlsl_inlet\fP in, int32_t * data_buffer, double * timestamp_buffer, unsigned long data_buffer_elements, unsigned long timestamp_buffer_elements, double timeout, int32_t * ec)"

.SS "\fBLIBLSL_C_API\fP unsigned long lsl::lsl_pull_chunk_l (\fBlsl_inlet\fP in, long * data_buffer, double * timestamp_buffer, unsigned long data_buffer_elements, unsigned long timestamp_buffer_elements, double timeout, int * ec)"

.SS "\fBLIBLSL_C_API\fP unsigned long lsl::lsl_pull_chunk_s (\fBlsl_inlet\fP in, int16_t * data_buffer, double * timestamp_buffer, unsigned long data_buffer_elements, unsigned long timestamp_buffer_elements, double timeout, int32_t * ec)"

.SS "\fBLIBLSL_C_API\fP unsigned long lsl::lsl_pull_chunk_str (\fBlsl_inlet\fP in, char ** data_buffer, double * timestamp_buffer, unsigned long data_buffer_elements, unsigned long timestamp_buffer_elements, double timeout, int32_t * ec)"

.SS "\fBLIBLSL_C_API\fP double lsl::lsl_pull_sample_buf (\fBlsl_inlet\fP in, char ** buffer, uint32_t * buffer_lengths, int32_t buffer_elements, double timeout, int32_t * ec)"
Pull a sample from the inlet and read it into an array of binary strings\&. These strings may contains 0's, therefore the lengths are read into the buffer_lengths array\&. Handles type checking & conversion\&. 
.PP
\fBParameters:\fP
.RS 4
\fIin\fP The lsl_inlet object to act on\&. 
.br
\fIbuffer\fP A pointer to hold the resulting data\&. 
.br
\fIbuffer_lengths\fP A pointer to an array that holds the resulting lengths for each returned binary string\&. 
.br
\fIbuffer_elements\fP The number of samples allocated in the buffer and buffer_lengths variables\&. Note: it is the responsibility of the user to allocate enough memory\&. 
.br
\fItimeout\fP The timeout for this operation, if any\&. Use LSL_FOREVER to effectively disable it\&. It is also permitted to use 0\&.0 here; in this case a sample is only returned if one is currently buffered\&. 
.br
\fIec\fP Error code: can be either no error or lsl_lost_error (if the stream source has been lost)\&. Note: if the timeout expires before a new sample was received the function returns 0\&.0; ec is \fInot\fP set to lsl_timeout_error (because this case is not considered an error condition)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
The capture time of the sample on the remote machine, or 0\&.0 if no new sample was available\&. To remap this time stamp to the local clock, add the value returned by \fBlsl_time_correction()\fP to it\&. 
.RE
.PP

.SS "\fBLIBLSL_C_API\fP double lsl::lsl_pull_sample_c (\fBlsl_inlet\fP in, char * buffer, int32_t buffer_elements, double timeout, int32_t * ec)"

.SS "\fBLIBLSL_C_API\fP double lsl::lsl_pull_sample_d (\fBlsl_inlet\fP in, double * buffer, int32_t buffer_elements, double timeout, int32_t * ec)"

.SS "\fBLIBLSL_C_API\fP double lsl::lsl_pull_sample_f (\fBlsl_inlet\fP in, float * buffer, int32_t buffer_elements, double timeout, int32_t * ec)"
Pull a sample from the inlet and read it into a pointer to values\&. Handles type checking & conversion\&. 
.PP
\fBParameters:\fP
.RS 4
\fIin\fP The lsl_inlet object to act on\&. 
.br
\fIbuffer\fP A pointer to hold the resulting values\&. 
.br
\fIbuffer_elements\fP The number of samples allocated in the buffer\&. Note: it is the responsibility of the user to allocate enough memory\&. 
.br
\fItimeout\fP The timeout for this operation, if any\&. Use LSL_FOREVER to effectively disable it\&. It is also permitted to use 0\&.0 here; in this case a sample is only returned if one is currently buffered\&. 
.br
\fIec\fP Error code: can be either no error or lsl_lost_error (if the stream source has been lost)\&. Note: if the timeout expires before a new sample was received the function returns 0\&.0; ec is \fInot\fP set to lsl_timeout_error (because this case is not considered an error condition)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
The capture time of the sample on the remote machine, or 0\&.0 if no new sample was available\&. To remap this time stamp to the local clock, add the value returned by \fBlsl_time_correction()\fP to it\&. 
.RE
.PP

.SS "\fBLIBLSL_C_API\fP double lsl::lsl_pull_sample_i (\fBlsl_inlet\fP in, int32_t * buffer, int32_t buffer_elements, double timeout, int32_t * ec)"

.SS "\fBLIBLSL_C_API\fP double lsl::lsl_pull_sample_l (\fBlsl_inlet\fP in, long * buffer, int buffer_elements, double timeout, int * ec)"

.SS "\fBLIBLSL_C_API\fP double lsl::lsl_pull_sample_s (\fBlsl_inlet\fP in, int16_t * buffer, int32_t buffer_elements, double timeout, int32_t * ec)"

.SS "\fBLIBLSL_C_API\fP double lsl::lsl_pull_sample_str (\fBlsl_inlet\fP in, char ** buffer, int32_t buffer_elements, double timeout, int32_t * ec)"

.SS "\fBLIBLSL_C_API\fP double lsl::lsl_pull_sample_v (\fBlsl_inlet\fP in, void * buffer, int32_t buffer_bytes, double timeout, int32_t * ec)"
Pull a sample from the inlet and read it into a custom struct or buffer\&. Overall size checking but no type checking or conversion are done\&. Do not use for variable-size/string-formatted streams\&. 
.PP
\fBParameters:\fP
.RS 4
\fIin\fP The lsl_inlet object to act on\&. 
.br
\fIbuffer\fP Pointer to hold the sample data\&. Search for #pragma pack for information on how to pack structs appropriately\&. 
.br
\fIbuffer_bytes\fP Length of the array held by buffer in bytes, not items 
.br
\fItimeout\fP The timeout for this operation, if any\&. Aside from LSL_FOREVER it is also permitted to use 0\&.0 here; in this case a sample is only returned if one is currently buffered\&. 
.br
\fIec\fP Error code: can be either no error or lsl_lost_error (if the stream source has been lost)\&. Note: if the timeout expires before a new sample was received the function returns 0\&.0; ec is \fInot\fP set to lsl_timeout_error (because this case is not considered an error condition)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
The capture time of the sample on the remote machine, or 0\&.0 if no new sample was available\&. To remap this time stamp to the local clock, add the value returned by \&.time_correction() to it\&. 
.RE
.PP

.SS "\fBLIBLSL_C_API\fP int32_t lsl::lsl_push_chunk_buf (\fBlsl_outlet\fP out, const char ** data, const uint32_t * lengths, unsigned long data_elements)"

.SS "\fBLIBLSL_C_API\fP int32_t lsl::lsl_push_chunk_buft (\fBlsl_outlet\fP out, const char ** data, const uint32_t * lengths, unsigned long data_elements, double timestamp)"

.SS "\fBLIBLSL_C_API\fP int32_t lsl::lsl_push_chunk_buftn (\fBlsl_outlet\fP out, const char ** data, const uint32_t * lengths, unsigned long data_elements, const double * timestamps)"

.SS "\fBLIBLSL_C_API\fP int32_t lsl::lsl_push_chunk_buftnp (\fBlsl_outlet\fP out, const char ** data, const uint32_t * lengths, unsigned long data_elements, const double * timestamps, int32_t pushthrough)"

.SS "\fBLIBLSL_C_API\fP int32_t lsl::lsl_push_chunk_buftp (\fBlsl_outlet\fP out, const char ** data, const uint32_t * lengths, unsigned long data_elements, double timestamp, int32_t pushthrough)"

.SS "\fBLIBLSL_C_API\fP int32_t lsl::lsl_push_chunk_c (\fBlsl_outlet\fP out, const char * data, unsigned long data_elements)"

.SS "\fBLIBLSL_C_API\fP int32_t lsl::lsl_push_chunk_ct (\fBlsl_outlet\fP out, const char * data, unsigned long data_elements, double timestamp)"

.SS "\fBLIBLSL_C_API\fP int32_t lsl::lsl_push_chunk_ctn (\fBlsl_outlet\fP out, const char * data, unsigned long data_elements, const double * timestamps)"

.SS "\fBLIBLSL_C_API\fP int32_t lsl::lsl_push_chunk_ctnp (\fBlsl_outlet\fP out, const char * data, unsigned long data_elements, const double * timestamps, int32_t pushthrough)"

.SS "\fBLIBLSL_C_API\fP int32_t lsl::lsl_push_chunk_ctp (\fBlsl_outlet\fP out, const char * data, unsigned long data_elements, double timestamp, int32_t pushthrough)"

.SS "\fBLIBLSL_C_API\fP int32_t lsl::lsl_push_chunk_d (\fBlsl_outlet\fP out, const double * data, unsigned long data_elements)"

.SS "\fBLIBLSL_C_API\fP int32_t lsl::lsl_push_chunk_dt (\fBlsl_outlet\fP out, const double * data, unsigned long data_elements, double timestamp)"

.SS "\fBLIBLSL_C_API\fP int32_t lsl::lsl_push_chunk_dtn (\fBlsl_outlet\fP out, const double * data, unsigned long data_elements, const double * timestamps)"

.SS "\fBLIBLSL_C_API\fP int32_t lsl::lsl_push_chunk_dtnp (\fBlsl_outlet\fP out, const double * data, unsigned long data_elements, const double * timestamps, int32_t pushthrough)"

.SS "\fBLIBLSL_C_API\fP int32_t lsl::lsl_push_chunk_dtp (\fBlsl_outlet\fP out, const double * data, unsigned long data_elements, double timestamp, int32_t pushthrough)"

.SS "\fBLIBLSL_C_API\fP int32_t lsl::lsl_push_chunk_f (\fBlsl_outlet\fP out, const float * data, unsigned long data_elements)"
Push a chunk of multiplexed samples into the outlet\&. One timestamp per sample is provided\&. IMPORTANT: Note that the provided buffer size is measured in channel values (e\&.g\&., floats) rather than in samples\&. Handles type checking & conversion\&. 
.PP
\fBParameters:\fP
.RS 4
\fIout\fP The lsl_outlet object through which to push the data\&. 
.br
\fIdata\fP A buffer of channel values holding the data for zero or more successive samples to send\&. 
.br
\fIlengths\fP For lsl_push_chunk_buf*, a pointer the number of elements to push for each value (string lengths)\&. 
.br
\fItimestamp\fP Optionally the capture time of the most recent sample, in agreement with \fBlocal_clock()\fP; if omitted, the current time is used\&. The time stamps of other samples are automatically derived based on the sampling rate of the stream\&. 
.br
\fItimestamps\fP Alternatively a buffer of timestamp values holding time stamps for each sample in the data buffer\&. 
.br
\fIdata_elements\fP The number of data values (of type T) in the data buffer\&. Must be a multiple of the channel count\&. 
.br
\fIpushthrough\fP Whether to push the chunk through to the receivers instead of buffering it with subsequent samples\&. Note that the chunk_size, if specified at outlet construction, takes precedence over the pushthrough flag\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Error code of the operation (usually attributed to the wrong data type)\&. 
.RE
.PP

.SS "\fBLIBLSL_C_API\fP int32_t lsl::lsl_push_chunk_ft (\fBlsl_outlet\fP out, const float * data, unsigned long data_elements, double timestamp)"

.SS "\fBLIBLSL_C_API\fP int32_t lsl::lsl_push_chunk_ftn (\fBlsl_outlet\fP out, const float * data, unsigned long data_elements, const double * timestamps)"

.SS "\fBLIBLSL_C_API\fP int32_t lsl::lsl_push_chunk_ftnp (\fBlsl_outlet\fP out, const float * data, unsigned long data_elements, const double * timestamps, int32_t pushthrough)"

.SS "\fBLIBLSL_C_API\fP int32_t lsl::lsl_push_chunk_ftp (\fBlsl_outlet\fP out, const float * data, unsigned long data_elements, double timestamp, int32_t pushthrough)"

.SS "\fBLIBLSL_C_API\fP int32_t lsl::lsl_push_chunk_i (\fBlsl_outlet\fP out, const int32_t * data, unsigned long data_elements)"

.SS "\fBLIBLSL_C_API\fP int32_t lsl::lsl_push_chunk_it (\fBlsl_outlet\fP out, const int32_t * data, unsigned long data_elements, double timestamp)"

.SS "\fBLIBLSL_C_API\fP int32_t lsl::lsl_push_chunk_itn (\fBlsl_outlet\fP out, const int32_t * data, unsigned long data_elements, const double * timestamps)"

.SS "\fBLIBLSL_C_API\fP int32_t lsl::lsl_push_chunk_itnp (\fBlsl_outlet\fP out, const int32_t * data, unsigned long data_elements, const double * timestamps, int32_t pushthrough)"

.SS "\fBLIBLSL_C_API\fP int32_t lsl::lsl_push_chunk_itp (\fBlsl_outlet\fP out, const int32_t * data, unsigned long data_elements, double timestamp, int32_t pushthrough)"

.SS "\fBLIBLSL_C_API\fP int lsl::lsl_push_chunk_l (\fBlsl_outlet\fP out, const long * data, unsigned long data_elements)"

.SS "\fBLIBLSL_C_API\fP int lsl::lsl_push_chunk_lt (\fBlsl_outlet\fP out, const long * data, unsigned long data_elements, double timestamp)"

.SS "\fBLIBLSL_C_API\fP int lsl::lsl_push_chunk_ltn (\fBlsl_outlet\fP out, const long * data, unsigned long data_elements, const double * timestamps)"

.SS "\fBLIBLSL_C_API\fP int lsl::lsl_push_chunk_ltnp (\fBlsl_outlet\fP out, const long * data, unsigned long data_elements, const double * timestamps, int pushthrough)"

.SS "\fBLIBLSL_C_API\fP int lsl::lsl_push_chunk_ltp (\fBlsl_outlet\fP out, const long * data, unsigned long data_elements, double timestamp, int pushthrough)"

.SS "\fBLIBLSL_C_API\fP int32_t lsl::lsl_push_chunk_s (\fBlsl_outlet\fP out, const int16_t * data, unsigned long data_elements)"

.SS "\fBLIBLSL_C_API\fP int32_t lsl::lsl_push_chunk_st (\fBlsl_outlet\fP out, const int16_t * data, unsigned long data_elements, double timestamp)"

.SS "\fBLIBLSL_C_API\fP int32_t lsl::lsl_push_chunk_stn (\fBlsl_outlet\fP out, const int16_t * data, unsigned long data_elements, const double * timestamps)"

.SS "\fBLIBLSL_C_API\fP int32_t lsl::lsl_push_chunk_stnp (\fBlsl_outlet\fP out, const int16_t * data, unsigned long data_elements, const double * timestamps, int32_t pushthrough)"

.SS "\fBLIBLSL_C_API\fP int32_t lsl::lsl_push_chunk_stp (\fBlsl_outlet\fP out, const int16_t * data, unsigned long data_elements, double timestamp, int32_t pushthrough)"

.SS "\fBLIBLSL_C_API\fP int32_t lsl::lsl_push_chunk_str (\fBlsl_outlet\fP out, const char ** data, unsigned long data_elements)"

.SS "\fBLIBLSL_C_API\fP int32_t lsl::lsl_push_chunk_strt (\fBlsl_outlet\fP out, const char ** data, unsigned long data_elements, double timestamp)"

.SS "\fBLIBLSL_C_API\fP int32_t lsl::lsl_push_chunk_strtn (\fBlsl_outlet\fP out, const char ** data, unsigned long data_elements, const double * timestamps)"

.SS "\fBLIBLSL_C_API\fP int32_t lsl::lsl_push_chunk_strtnp (\fBlsl_outlet\fP out, const char ** data, unsigned long data_elements, const double * timestamps, int32_t pushthrough)"

.SS "\fBLIBLSL_C_API\fP int32_t lsl::lsl_push_chunk_strtp (\fBlsl_outlet\fP out, const char ** data, unsigned long data_elements, double timestamp, int32_t pushthrough)"

.SS "\fBLIBLSL_C_API\fP int32_t lsl::lsl_push_sample_buf (\fBlsl_outlet\fP out, const char ** data, const uint32_t * lengths)"

.SS "\fBLIBLSL_C_API\fP int32_t lsl::lsl_push_sample_buft (\fBlsl_outlet\fP out, const char ** data, const uint32_t * lengths, double timestamp)"

.SS "\fBLIBLSL_C_API\fP int32_t lsl::lsl_push_sample_buftp (\fBlsl_outlet\fP out, const char ** data, const uint32_t * lengths, double timestamp, int32_t pushthrough)"

.SS "\fBLIBLSL_C_API\fP int32_t lsl::lsl_push_sample_c (\fBlsl_outlet\fP out, const char * data)"

.SS "\fBLIBLSL_C_API\fP int32_t lsl::lsl_push_sample_ct (\fBlsl_outlet\fP out, const char * data, double timestamp)"

.SS "\fBLIBLSL_C_API\fP int32_t lsl::lsl_push_sample_ctp (\fBlsl_outlet\fP out, const char * data, double timestamp, int32_t pushthrough)"

.SS "\fBLIBLSL_C_API\fP int32_t lsl::lsl_push_sample_d (\fBlsl_outlet\fP out, const double * data)"

.SS "\fBLIBLSL_C_API\fP int32_t lsl::lsl_push_sample_dt (\fBlsl_outlet\fP out, const double * data, double timestamp)"

.SS "\fBLIBLSL_C_API\fP int32_t lsl::lsl_push_sample_dtp (\fBlsl_outlet\fP out, const double * data, double timestamp, int32_t pushthrough)"

.SS "\fBLIBLSL_C_API\fP int32_t lsl::lsl_push_sample_f (\fBlsl_outlet\fP out, const float * data)"
Push a pointer to some values as a sample into the outlet\&. Handles type checking & conversion\&. 
.PP
\fBParameters:\fP
.RS 4
\fIout\fP The lsl_outlet object through which to push the data\&. 
.br
\fIdata\fP A pointer to values to push\&. The number of values pointed to must be no less than the number of channels in the sample\&. 
.br
\fIlengths\fP For lsl_push_sample_buf*, a pointer the number of elements to push for each channel (string lengths)\&. 
.br
\fItimestamp\fP Optionally the capture time of the sample, in agreement with \fBlsl_local_clock()\fP; if omitted, the current time is used\&. 
.br
\fIpushthrough\fP Whether to push the sample through to the receivers instead of buffering it with subsequent samples\&. Note that the chunk_size, if specified at outlet construction, takes precedence over the pushthrough flag\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Error code of the operation or lsl_no_error if successful (usually attributed to the wrong data type)\&. 
.RE
.PP

.SS "\fBLIBLSL_C_API\fP int32_t lsl::lsl_push_sample_ft (\fBlsl_outlet\fP out, const float * data, double timestamp)"

.SS "\fBLIBLSL_C_API\fP int32_t lsl::lsl_push_sample_ftp (\fBlsl_outlet\fP out, const float * data, double timestamp, int32_t pushthrough)"

.SS "\fBLIBLSL_C_API\fP int32_t lsl::lsl_push_sample_i (\fBlsl_outlet\fP out, const int32_t * data)"

.SS "\fBLIBLSL_C_API\fP int32_t lsl::lsl_push_sample_it (\fBlsl_outlet\fP out, const int32_t * data, double timestamp)"

.SS "\fBLIBLSL_C_API\fP int32_t lsl::lsl_push_sample_itp (\fBlsl_outlet\fP out, const int32_t * data, double timestamp, int32_t pushthrough)"

.SS "\fBLIBLSL_C_API\fP int32_t lsl::lsl_push_sample_l (\fBlsl_outlet\fP out, const long * data)"

.SS "\fBLIBLSL_C_API\fP int32_t lsl::lsl_push_sample_lt (\fBlsl_outlet\fP out, const long * data, double timestamp)"

.SS "\fBLIBLSL_C_API\fP int32_t lsl::lsl_push_sample_ltp (\fBlsl_outlet\fP out, const long * data, double timestamp, int32_t pushthrough)"

.SS "\fBLIBLSL_C_API\fP int32_t lsl::lsl_push_sample_s (\fBlsl_outlet\fP out, const int16_t * data)"

.SS "\fBLIBLSL_C_API\fP int32_t lsl::lsl_push_sample_st (\fBlsl_outlet\fP out, const int16_t * data, double timestamp)"

.SS "\fBLIBLSL_C_API\fP int32_t lsl::lsl_push_sample_stp (\fBlsl_outlet\fP out, const int16_t * data, double timestamp, int32_t pushthrough)"

.SS "\fBLIBLSL_C_API\fP int32_t lsl::lsl_push_sample_str (\fBlsl_outlet\fP out, const char ** data)"

.SS "\fBLIBLSL_C_API\fP int32_t lsl::lsl_push_sample_strt (\fBlsl_outlet\fP out, const char ** data, double timestamp)"

.SS "\fBLIBLSL_C_API\fP int32_t lsl::lsl_push_sample_strtp (\fBlsl_outlet\fP out, const char ** data, double timestamp, int32_t pushthrough)"

.SS "\fBLIBLSL_C_API\fP int32_t lsl::lsl_push_sample_v (\fBlsl_outlet\fP out, const void * data)"

.SS "\fBLIBLSL_C_API\fP int32_t lsl::lsl_push_sample_vt (\fBlsl_outlet\fP out, const void * data, double timestamp)"

.SS "\fBLIBLSL_C_API\fP int32_t lsl::lsl_push_sample_vtp (\fBlsl_outlet\fP out, const void * data, double timestamp, int32_t pushthrough)"

.SS "\fBLIBLSL_C_API\fP void lsl::lsl_remove_child (\fBlsl_xml_ptr\fP e, \fBlsl_xml_ptr\fP e2)"
Remove a specified child element\&. 
.SS "\fBLIBLSL_C_API\fP void lsl::lsl_remove_child_n (\fBlsl_xml_ptr\fP e, const char * name)"
Remove a child element with the specified name\&. 
.SS "\fBLIBLSL_C_API\fP int32_t lsl::lsl_resolve_all (\fBlsl_streaminfo\fP * buffer, uint32_t buffer_elements, double wait_time)"
Resolve all streams on the network\&. This function returns all currently available streams from any outlet on the network\&. The network is usually the subnet specified at the local router, but may also include a multicast group of machines (given that the network supports it), or a list of hostnames\&. These details may optionally be customized by the experimenter in a configuration file (see page Network Connectivity in the LSL wiki)\&. This is the default mechanism used by the browsing programs and the recording program\&. 
.PP
\fBParameters:\fP
.RS 4
\fIbuffer\fP A user-allocated buffer to hold the resolve results\&. Note: it is the user's responsibility to either destroy the resulting streaminfo objects or to pass them back to the LSL during during creation of an inlet\&. Note 2: The \fBstream_info\fP's returned by the resolver are only short versions that do not include the \&.desc() field (which can be arbitrarily big)\&. To obtain the full stream information you need to call \&.info() on the inlet after you have created one\&. 
.br
\fIbuffer_elements\fP The user-provided buffer length\&. 
.br
\fIwait_time\fP The waiting time for the operation, in seconds, to search for streams\&. The recommended wait time is 1 second (or 2 for a busy and large recording operation)\&. Warning: If this is too short (<0\&.5s) only a subset (or none) of the outlets that are present on the network may be returned\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
The number of results written into the buffer (never more than the provided # of slots) or a negative number if an error has occurred (values corresponding to lsl_error_code_t)\&. 
.RE
.PP

.SS "\fBLIBLSL_C_API\fP int32_t lsl::lsl_resolve_bypred (\fBlsl_streaminfo\fP * buffer, uint32_t buffer_elements, const char * pred, int32_t minimum, double timeout)"
Resolve all streams that match a given predicate\&. Advanced query that allows to impose more conditions on the retrieved streams; the given string is an XPath 1\&.0 predicate for the <info> node (omitting the surrounding []'s), see also http://en.wikipedia.org/w/index.php?title=XPath_1.0&oldid=474981951\&. 
.PP
\fBParameters:\fP
.RS 4
\fIbuffer\fP A user-allocated buffer to hold the resolve results\&. Note: it is the user's responsibility to either destroy the resulting streaminfo objects or to pass them back to the LSL during during creation of an inlet\&. Note 2: The \fBstream_info\fP's returned by the resolver are only short versions that do not include the \&.desc() field (which can be arbitrarily big)\&. To obtain the full stream information you need to call \&.info() on the inlet after you have created one\&. 
.br
\fIbuffer_elements\fP The user-provided buffer length\&. 
.br
\fIpred\fP The predicate string, e\&.g\&. 'name='BioSemi'' or 'type='EEG' and starts-with(name,'BioSemi') and count(info/desc/channel)=32' 
.br
\fIminimum\fP Return at least this number of streams\&. 
.br
\fItimeout\fP Optionally a timeout of the operation, in seconds (default: no timeout)\&. If the timeout expires, less than the desired number of streams (possibly none) will be returned\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
The number of results written into the buffer (never more than the provided # of slots) or a negative number if an error has occurred (values corresponding to lsl_error_code_t)\&. 
.RE
.PP

.SS "\fBLIBLSL_C_API\fP int32_t lsl::lsl_resolve_byprop (\fBlsl_streaminfo\fP * buffer, uint32_t buffer_elements, const char * prop, const char * value, int32_t minimum, double timeout)"
Resolve all streams with a given value for a property\&. If the goal is to resolve a specific stream, this method is preferred over resolving all streams and then selecting the desired one\&. 
.PP
\fBParameters:\fP
.RS 4
\fIbuffer\fP A user-allocated buffer to hold the resolve results\&. Note: it is the user's responsibility to either destroy the resulting streaminfo objects or to pass them back to the LSL during during creation of an inlet\&. Note 2: The \fBstream_info\fP's returned by the resolver are only short versions that do not include the \&.desc() field (which can be arbitrarily big)\&. To obtain the full stream information you need to call \&.info() on the inlet after you have created one\&. 
.br
\fIbuffer_elements\fP The user-provided buffer length\&. 
.br
\fIprop\fP The streaminfo property that should have a specific value ('name', 'type', 'source_id', or, e\&.g\&., 'desc/manufaturer' if present)\&. 
.br
\fIvalue\fP The string value that the property should have (e\&.g\&., 'EEG' as the type)\&. 
.br
\fIminimum\fP Return at least this number of streams\&. 
.br
\fItimeout\fP Optionally a timeout of the operation, in seconds (default: no timeout)\&. If the timeout expires, less than the desired number of streams (possibly none) will be returned\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
The number of results written into the buffer (never more than the provided # of slots) or a negative number if an error has occurred (values corresponding to lsl_error_code_t)\&. 
.RE
.PP

.SS "\fBLIBLSL_C_API\fP int32_t lsl::lsl_resolver_results (\fBlsl_continuous_resolver\fP res, \fBlsl_streaminfo\fP * buffer, uint32_t buffer_elements)"
Obtain the set of currently present streams on the network (i\&.e\&. resolve result)\&. 
.PP
\fBParameters:\fP
.RS 4
\fIres\fP A continuous resolver (previously created with one of the lsl_create_continuous_resolver functions)\&. 
.br
\fIbuffer\fP A user-allocated buffer to hold the current resolve results\&. Note: it is the user's responsibility to either destroy the resulting streaminfo objects or to pass them back to the LSL during during creation of an inlet\&. Note 2: The \fBstream_info\fP's returned by the resolver are only short versions that do not include the \&.desc() field (which can be arbitrarily big)\&. To obtain the full stream information you need to call \&.info() on the inlet after you have created one\&. 
.br
\fIbuffer_elements\fP The user-provided buffer length\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
The number of results written into the buffer (never more than the provided # of slots) or a negative number if an error has occurred (values corresponding to lsl_error_code_t)\&. 
.RE
.PP

.SS "\fBLIBLSL_C_API\fP uint32_t lsl::lsl_samples_available (\fBlsl_inlet\fP in)"
Query whether samples are currently available for immediate pickup\&. Note that it is not a good idea to use samples_available() to determine whether a pull_*() call would block: to be sure, set the pull timeout to 0\&.0 or an acceptably low value\&. If the underlying implementation supports it, the value will be the number of samples available (otherwise it will be 1 or 0)\&. 
.SS "\fBLIBLSL_C_API\fP int32_t lsl::lsl_set_child_value (\fBlsl_xml_ptr\fP e, const char * name, const char * value)"
Set the text value of the (nameless) plain-text child of a named child node\&. 
.SS "\fBLIBLSL_C_API\fP int32_t lsl::lsl_set_name (\fBlsl_xml_ptr\fP e, const char * rhs)"
Set the element's name\&. 
.PP
\fBReturns:\fP
.RS 4
0 if the node is empty (or if out of memory)\&. 
.RE
.PP

.SS "\fBLIBLSL_C_API\fP int32_t lsl::lsl_set_postprocessing (\fBlsl_inlet\fP in, uint32_t flags)"
Set post-processing flags to use\&. By default, the inlet performs NO post-processing and returns the ground-truth time stamps, which can then be manually synchronized using time_correction(), and then smoothed/dejittered if desired\&. This function allows automating these two and possibly more operations\&. Warning: when you enable this, you will no longer receive or be able to recover the original time stamps\&. 
.PP
\fBParameters:\fP
.RS 4
\fIin\fP The lsl_inlet object to act on\&. 
.br
\fIflags\fP An integer that is the result of bitwise OR'ing one or more options from processing_options_t together (e\&.g\&., post_clocksync|post_dejitter); a good setting is to use post_ALL\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
The error code: if nonzero, can be lsl_argument_error if an unknown flag was passed in\&. 
.RE
.PP

.SS "\fBLIBLSL_C_API\fP int32_t lsl::lsl_set_value (\fBlsl_xml_ptr\fP e, const char * rhs)"
Set the element's value\&. 
.PP
\fBReturns:\fP
.RS 4
0 if the node is empty (or if out of memory)\&. 
.RE
.PP

.SS "\fBLIBLSL_C_API\fP int32_t lsl::lsl_smoothing_halftime (\fBlsl_inlet\fP in, float value)"
Override the half-time (forget factor) of the time-stamp smoothing\&. The default is 90 seconds unless a different value is set in the config file\&. Using a longer window will yield lower jitter in the time stamps, but longer windows will have trouble tracking changes in the clock rate (usually due to temperature changes); the default is able to track changes up to 10 degrees C per minute sufficiently well\&. 
.PP
\fBParameters:\fP
.RS 4
\fIin\fP The lsl_inlet object to act on\&. 
.br
\fIvalue\fP The new value, in seconds\&. This is the time after which a past sample will be weighted by 1/2 in the exponential smoothing window\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
The error code: if nonzero, can be lsl_argument_error if an unknown flag was passed in\&. 
.RE
.PP

.SS "\fBLIBLSL_C_API\fP int lsl::lsl_stream_info_matches_query (\fBlsl_streaminfo\fP info, const char * query)"
Tries to match the stream info XML element \fCinfo\fP against an \fCXPath\fP query\&.
.PP
Example query strings: 
.PP
.nf
channel_count>5 and type='EEG'
type='TestStream' or contains(name,'Brain')
name='ExampleStream'

.fi
.PP
 
.SS "\fBLIBLSL_C_API\fP \fBlsl_streaminfo\fP lsl::lsl_streaminfo_from_xml (const char * xml)"

.PP
Create a streaminfo object from an XML representation\&. 
.SS "\fBLIBLSL_C_API\fP double lsl::lsl_time_correction (\fBlsl_inlet\fP in, double timeout, int32_t * ec)"
Retrieve an estimated time correction offset for the given stream\&. The first call to this function takes several milliseconds until a reliable first estimate is obtained\&. Subsequent calls are instantaneous (and rely on periodic background updates)\&. On a well-behaved network, the precision of these estimates should be below 1 ms (empirically it is within +/-0\&.2 ms)\&. To get a measure of whether the network is well-behaved, use lsl_time_correction_ex and check uncertainty (which maps to round-trip-time)\&. 0\&.2 ms is typical of wired networks\&. 2 ms is typical of wireless networks\&. The number can be much higher on poor networks\&.
.PP
\fBParameters:\fP
.RS 4
\fIin\fP The lsl_inlet object to act on\&. 
.br
\fIremote_time\fP The current time of the remote computer that was used to generate this time_correction\&. If desired, the client can fit time_correction vs remote_time to improve the real-time time_correction further\&. 
.br
\fIuncertainty\&.\fP The maximum uncertainty of the given time correction\&. 
.br
\fItimeout\fP Timeout to acquire the first time-correction estimate\&. Use LSL_FOREVER to defuse the timeout\&. 
.br
\fIec\fP Error code: if nonzero, can be either lsl_timeout_error (if the timeout has expired) or lsl_lost_error (if the stream source has been lost)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
The time correction estimate\&. This is the number that needs to be added to a time stamp that was remotely generated via \fBlsl_local_clock()\fP to map it into the local clock domain of this machine\&. 
.RE
.PP

.SS "\fBLIBLSL_C_API\fP double lsl::lsl_time_correction_ex (\fBlsl_inlet\fP in, double * remote_time, double * uncertainty, double timeout, int32_t * ec)"

.SS "\fBLIBLSL_C_API\fP const char* lsl::lsl_value (\fBlsl_xml_ptr\fP e)"
Value of the element\&. 
.SS "\fBLIBLSL_C_API\fP int32_t lsl::lsl_wait_for_consumers (\fBlsl_outlet\fP out, double timeout)"
Wait until some consumer shows up (without wasting resources)\&. 
.PP
\fBReturns:\fP
.RS 4
True if the wait was successful, false if the timeout expired\&. 
.RE
.PP

.SS "\fBLIBLSL_C_API\fP uint32_t lsl::lsl_was_clock_reset (\fBlsl_inlet\fP in)"
Query whether the clock was potentially reset since the last call to was_clock_reset()\&. This is rarely-used function is only needed for applications that combine multiple time_correction values to estimate precise clock drift if they should tolerate cases where the source machine was hot-swapped or restarted\&. 
.SS "int32_t lsl::protocol_version ()\fC [inline]\fP"
Protocol version\&. The major version is \fBprotocol_version()\fP / 100; The minor version is \fBprotocol_version()\fP % 100; Clients with different minor versions are protocol-compatible with each other while clients with different major versions will refuse to work together\&. 
.SS "std::vector<\fBstream_info\fP> lsl::resolve_stream (const std::string & prop, const std::string & value, int32_t minimum = \fC1\fP, double timeout = \fC\fBFOREVER\fP\fP)\fC [inline]\fP"
Resolve all streams with a specific value for a given property\&. If the goal is to resolve a specific stream, this method is preferred over resolving all streams and then selecting the desired one\&. 
.PP
\fBParameters:\fP
.RS 4
\fIprop\fP The \fBstream_info\fP property that should have a specific value (e\&.g\&., 'name', 'type', 'source_id', or 'desc/manufaturer')\&. 
.br
\fIvalue\fP The string value that the property should have (e\&.g\&., 'EEG' as the type property)\&. 
.br
\fIminimum\fP Return at least this number of streams\&. 
.br
\fItimeout\fP Optionally a timeout of the operation, in seconds (default: no timeout)\&. If the timeout expires, less than the desired number of streams (possibly none) will be returned\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
A vector of matching stream info objects (excluding their meta-data), any of which can subsequently be used to open an inlet\&. 
.RE
.PP

.SS "std::vector<\fBstream_info\fP> lsl::resolve_stream (const std::string & pred, int32_t minimum = \fC1\fP, double timeout = \fC\fBFOREVER\fP\fP)\fC [inline]\fP"
Resolve all streams that match a given predicate\&. Advanced query that allows to impose more conditions on the retrieved streams; the given string is an XPath 1\&.0 predicate for the <info> node (omitting the surrounding []'s), see also http://en.wikipedia.org/w/index.php?title=XPath_1.0&oldid=474981951\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpred\fP The predicate string, e\&.g\&. 'name='BioSemi'' or 'type='EEG' and starts-with(name,'BioSemi') and count(info/desc/channel)=32' 
.br
\fIminimum\fP Return at least this number of streams\&. 
.br
\fItimeout\fP Optionally a timeout of the operation, in seconds (default: no timeout)\&. If the timeout expires, less than the desired number of streams (possibly none) will be returned\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
A vector of matching stream info objects (excluding their meta-data), any of which can subsequently be used to open an inlet\&. 
.RE
.PP

.SS "std::vector<\fBstream_info\fP> lsl::resolve_streams (double wait_time = \fC1\&.0\fP)\fC [inline]\fP"
Resolve all streams on the network\&. This function returns all currently available streams from any outlet on the network\&. The network is usually the subnet specified at the local router, but may also include a multicast group of machines (given that the network supports it), or list of hostnames\&. These details may optionally be customized by the experimenter in a configuration file (see Network Connectivity in the LSL wiki)\&. This is the default mechanism used by the browsing programs and the recording program\&. 
.PP
\fBParameters:\fP
.RS 4
\fIwait_time\fP The waiting time for the operation, in seconds, to search for streams\&. Warning: If this is too short (<0\&.5s) only a subset (or none) of the outlets that are present on the network may be returned\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
A vector of stream info objects (excluding their desc field), any of which can subsequently be used to open an inlet\&. The full info can be retrieve from the inlet\&. 
.RE
.PP

.SH "Variable Documentation"
.PP 
.SS "const double lsl::DEDUCED_TIMESTAMP = \-1\&.0"
Constant to indicate that a sample has the next successive time stamp\&. This is an optional optimization to transmit less data per sample\&. The stamp is then deduced from the preceding one according to the stream's sampling rate (in the case of an irregular rate, the same time stamp as before will is assumed)\&. 
.SS "const double lsl::FOREVER = 32000000\&.0"
A very large time duration (> 1 year) for timeout values\&. Note that significantly larger numbers can cause the timeout to be invalid on some operating systems (e\&.g\&., 32-bit UNIX)\&. 
.SS "const double lsl::IRREGULAR_RATE = 0\&.0"
Constant to indicate that a stream has variable sampling rate\&. 
.SH "Author"
.PP 
Generated automatically by Doxygen for lslsub_dbfeeder from the source code\&.
